<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb" xmlns:nxe="http://www.ndg.com/xmleditor/1.0.0"
	xmlns:map="http://www.ndg.com/map" xmlns:momimecommon="http://momime/common/database" targetNamespace="http://momime/common/database"
	jaxb:version="2.0">
	
	<xsd:import namespace="http://www.ndg.com/map" />
	
    <xsd:annotation>
    	<xsd:documentation>Defines the portions of the main data XML file that are needed both by the client and server.
Note this excludes runtime knowledge data structures - these are in MoMIMEMessages.xsd.  Only structures that exist in one of the XML files are defined here.</xsd:documentation>
	</xsd:annotation>

<!-- Types used in the new game database that the server sends to each client before they create a session so they know available databases and new game params -->

	<xsd:complexType name="overlandMapSize">
        <xsd:annotation>
        	<xsd:documentation>Defines standard map sizes, i.e. 60x40.</xsd:documentation>
        </xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="map:coordinateSystem">
				<xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="zoneWidth" type="map:mapDimension" nxe:label="Zone Width" nxe:gridwidth="100" />
					<xsd:element minOccurs="1" maxOccurs="1" name="zoneHeight" type="map:mapDimension" nxe:label="Zone Height" nxe:gridwidth="100" />
					<xsd:element minOccurs="1" maxOccurs="1" name="towersOfWizardryCount" type="momimecommon:mapTileCount" nxe:label="Nbr. Towers of Wizardry" nxe:gridwidth="150" />
					<xsd:element minOccurs="1" maxOccurs="1" name="towersOfWizardrySeparation" type="momimecommon:integerMapDistance" nxe:label="Towers of Wizardry separation" nxe:gridwidth="180" />
					<xsd:element minOccurs="1" maxOccurs="1" name="continentalRaceChance" type="momimecommon:percentage" nxe:label="% chance that raider cities are the race chosen for the continent" nxe:gridwidth="300" />
					<xsd:element minOccurs="1" maxOccurs="1" name="citySeparation" type="momimecommon:integerMapDistance" nxe:label="City separation" nxe:gridwidth="100" />
					<xsd:element minOccurs="1" maxOccurs="1" name="raiderCityCount" type="momimecommon:cityCount" nxe:label="Nbr. raider cities" nxe:gridwidth="100" />
					<xsd:element minOccurs="1" maxOccurs="1" name="riverCount" type="momimecommon:mapTileCount" nxe:label="Nbr. Rivers on each plane" nxe:gridwidth="150" />
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="mapSizePlane" type="momimecommon:mapSizePlane" />
				</xsd:sequence>
				<xsd:attribute name="overlandMapSizeID" type="momimecommon:overlandMapSizeID" use="optional" nxe:label="Map Size ID" nxe:gridwidth="80" />
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="mapSizePlane" nxe:singular="Map Size Plane" nxe:plural="Map Size Planes">
        <xsd:annotation>
        	<xsd:documentation>Defines map size details that are different on each plane.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="numberOfNodesOnPlane" type="momimecommon:numberOfNodesOnPlane" nxe:label="Number of nodes on Plane" nxe:gridwidth="150" />
		</xsd:sequence>
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="landProportion">
        <xsd:annotation>
        	<xsd:documentation>Defines land proportions choosable on the new game form, i.e. small/medium/large.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="percentageOfMapIsLand" type="momimecommon:percentage" nxe:label="% of map which is land" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="percentageOfLandIsHills" type="momimecommon:percentage" nxe:label="% of land which is hills" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="percentageOfHillsAreMountains" type="momimecommon:percentage" nxe:label="% of hills which are mountains" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="tundraRowCount" type="momimecommon:mapTileCount" nxe:label="Nbr. rows from map edge where tundra can appear" nxe:gridwidth="270" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="landProportionTileType" type="momimecommon:landProportionTileType" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="landProportionPlane" type="momimecommon:landProportionPlane" />
		</xsd:sequence>
		<xsd:attribute name="landProportionID" type="momimecommon:landProportionID" use="optional" nxe:label="Land Proportion ID" nxe:gridwidth="120" />
	</xsd:complexType>
	
	<xsd:complexType name="landProportionTileType" nxe:singular="Land Proportion Tile Type" nxe:plural="Land Proportion Tile Types">
        <xsd:annotation>
        	<xsd:documentation>Defines charactistics of terrain which is generated in blobs (trees, desert and swamp).</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="percentageOfLand" type="momimecommon:percentage" nxe:label="% of land which is this terrain" nxe:gridwidth="180" />
			<xsd:element minOccurs="1" maxOccurs="1" name="eachAreaTileCount" type="momimecommon:mapTileCount" nxe:label="Approx. size of each area of this terrain" nxe:gridwidth="220" />
		</xsd:sequence>
		<xsd:attribute name="tileTypeID" type="momimecommon:tileTypeID" use="required" nxe:label="Tile Type ID" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>tileTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="landProportionPlane" nxe:singular="Land Proportion Plane" nxe:plural="Land Proportion Planes">
        <xsd:annotation>
        	<xsd:documentation>Defines land proportion values that are different on each plane.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="featureChance" type="momimecommon:featureChance" nxe:label="1 in X chance of each terrain tile gaining a special feature/mineral" nxe:gridwidth="350" />
		</xsd:sequence>
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="nodeStrength">
        <xsd:annotation>
        	<xsd:documentation>Defines node strengths choosable on the new game form, i.e. weak/normal/powerful.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="doubleNodeAuraMagicPower" type="momimecommon:doubledProductionValue" nxe:label="2x node aura magic power" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="nodeStrengthPlane" type="momimecommon:nodeStrengthPlane" />
		</xsd:sequence>
		<xsd:attribute name="nodeStrengthID" type="momimecommon:nodeStrengthID" use="optional" nxe:label="Node Strength ID" nxe:gridwidth="150" />
	</xsd:complexType>

	<xsd:complexType name="nodeStrengthPlane" nxe:singular="Node Strength Plane" nxe:plural="Node Strength Planes">
        <xsd:annotation>
        	<xsd:documentation>Defines node strength characteristics that are different on each plane.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="nodeAuraSquaresMinimum" type="momimecommon:nodeAuraSqaures" nxe:label="Min. map cells node aura covers" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="nodeAuraSquaresMaximum" type="momimecommon:nodeAuraSqaures" nxe:label="Max. map cells node aura covers" nxe:gridwidth="200" />
		</xsd:sequence>
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="difficultyLevel">
        <xsd:annotation>
        	<xsd:documentation>Defines difficulty levels choosable on the new game form, i.e. intro/easy/normal/hard/impossible.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="humanSpellPicks" type="momimecommon:pickCount" nxe:label="Human spell picks" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="aiSpellPicks" type="momimecommon:pickCount" nxe:label="AI spell picks" nxe:gridwidth="90" />
			<xsd:element minOccurs="1" maxOccurs="1" name="humanStartingGold" type="momimecommon:undoubledProductionValue" nxe:label="Human starting gold" nxe:gridwidth="110" />
			<xsd:element minOccurs="1" maxOccurs="1" name="aiStartingGold" type="momimecommon:undoubledProductionValue" nxe:label="AI starting gold" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="customWizards" type="xsd:boolean" nxe:label="Custom wizards?" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="eachWizardOnlyOnce" type="xsd:boolean" nxe:label="Each wizard only once?" nxe:gridwidth="130" />
			<xsd:element minOccurs="1" maxOccurs="1" name="normalLairCount" type="momimecommon:lairCount" nxe:label="Nbr. normal lairs" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="weakLairCount" type="momimecommon:lairCount" nxe:label="Nbr. weak lairs" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="towerMonstersMinimum" type="momimecommon:monsterStrength" nxe:label="Tower Min. monster strength" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="towerMonstersMaximum" type="momimecommon:monsterStrength" nxe:label="Tower Max. monster strength" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="towerTreasureMinimum" type="momimecommon:treasureValue" nxe:label="Tower Min. treasure value" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="towerTreasureMaximum" type="momimecommon:treasureValue" nxe:label="Tower Max. treasure value" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="raiderCityStartSizeMin" type="momimecommon:cityPopulationDiv1000" nxe:label="Min. starting size of raider cities" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="raiderCityStartSizeMax" type="momimecommon:cityPopulationDiv1000" nxe:label="Max. starting size of raider cities" nxe:gridwidth="170" />
			<xsd:element minOccurs="1" maxOccurs="1" name="raiderCityGrowthCap" type="momimecommon:cityPopulationDiv1000" nxe:label="Amount raider cities are allowed to grow" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="wizardCityStartSize" type="momimecommon:cityPopulationDiv1000" nxe:label="Starting size of wizard cities" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="cityMaxSize" type="momimecommon:cityPopulationDiv1000" nxe:label="Max. city size" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="difficultyLevelPlane" type="momimecommon:difficultyLevelPlane" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="difficultyLevelNodeStrength" type="momimecommon:difficultyLevelNodeStrength" />
		</xsd:sequence>
		<xsd:attribute name="difficultyLevelID" type="momimecommon:difficultyLevelID" use="optional" nxe:label="Difficulty Level ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="difficultyLevelPlane" nxe:singular="Difficulty Level - Plane" nxe:plural="Difficulty Level - Planes">
        <xsd:annotation>
        	<xsd:documentation>Defines difficulty level settings that are different on each plane.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="normalLairMonstersMinimum" type="momimecommon:monsterStrength" nxe:label="Norm. Lair Min. monster strength" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="normalLairMonstersMaximum" type="momimecommon:monsterStrength" nxe:label="Norm. Lair Max. monster strength" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="normalLairTreasureMinimum" type="momimecommon:treasureValue" nxe:label="Norm. Lair Min. treasure value" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="normalLairTreasureMaximum" type="momimecommon:treasureValue" nxe:label="Norm. Lair Max. treasure value" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="weakLairMonstersMinimum" type="momimecommon:monsterStrength" nxe:label="Weak Lair Min. monster strength" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="weakLairMonstersMaximum" type="momimecommon:monsterStrength" nxe:label="Weak Lair Max. monster strength" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="weakLairTreasureMinimum" type="momimecommon:treasureValue" nxe:label="Weak Lair Min. treasure value" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="weakLairTreasureMaximum" type="momimecommon:treasureValue" nxe:label="Weak Lair Max. treasure value" nxe:gridwidth="200" />
		</xsd:sequence>
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="difficultyLevelNodeStrength" nxe:singular="Difficulty Level - Node Strength" nxe:plural="Difficulty Level - Node Strengths">
        <xsd:annotation>
        	<xsd:documentation>Defines difficulty level settings that are different with each node strength and on each plane.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="monstersMinimum" type="momimecommon:monsterStrength" nxe:label="Min. monster strength" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="monstersMaximum" type="momimecommon:monsterStrength" nxe:label="Max. monster strength" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="treasureMinimum" type="momimecommon:treasureValue" nxe:label="Min. treasure value" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="treasureMaximum" type="momimecommon:treasureValue" nxe:label="Max. treasure value" nxe:gridwidth="150" />
		</xsd:sequence>
		<xsd:attribute name="nodeStrengthID" type="momimecommon:nodeStrengthID" use="optional" nxe:label="Node Strength ID" nxe:showmaincolumn="false" />
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="fogOfWarSetting">
        <xsd:annotation>
        	<xsd:documentation>Defines standard fog of war settings choosable on the new game form, i.e. original/recommended.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="terrainAndNodeAuras" type="momimecommon:fogOfWarValue" nxe:label="Terrain and Node Auras" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="citiesSpellsAndCombatAreaEffects" type="momimecommon:fogOfWarValue" nxe:label="Cities, Combat Spells and CAEs" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="units" type="momimecommon:fogOfWarValue" nxe:label="Units" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="seeEnemyCityConstruction" type="xsd:boolean" nxe:label="See what enemy cities are constructing?" nxe:gridwidth="200" />
		</xsd:sequence>
		<xsd:attribute name="fogOfWarSettingID" type="momimecommon:fogOfWarSettingID" use="optional" nxe:label="Fog of War Setting ID" nxe:gridwidth="150" />
	</xsd:complexType>

	<xsd:complexType name="unitSetting">
        <xsd:annotation>
        	<xsd:documentation>Defines standard unit settings choosable on the new game form, i.e. original/recommended.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="unitsPerMapCell" type="momimecommon:unitCount" nxe:label="Max. units in a map cell" nxe:gridwidth="150" />
			<xsd:element minOccurs="1" maxOccurs="1" name="canExceedMaximumUnitsDuringCombat" type="xsd:boolean" nxe:label="Exceed limit during combat?" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="1" name="maxHeroes" type="momimecommon:unitCount" nxe:label="Max. heroes hired at once" nxe:gridwidth="150">
		        <xsd:annotation><xsd:documentation>null = unlimited.</xsd:documentation></xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="rollHeroSkillsAtStartOfGame" type="xsd:boolean" nxe:label="Roll hero skills at start of game?" nxe:gridwidth="170" />
			<xsd:element minOccurs="0" maxOccurs="1" name="maxHeroItemBonuses" type="momimecommon:spellCount" nxe:label="Max. bonuses added to hero item" nxe:gridwidth="200">
		        <xsd:annotation><xsd:documentation>null = unlimited.</xsd:documentation></xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="maxHeroItemSpellCharges" type="momimecommon:spellCount" nxe:label="Max. spell charges added to hero item" nxe:gridwidth="200" />
			<xsd:element minOccurs="0" maxOccurs="1" name="maxHeroItemsInBank" type="momimecommon:spellCount" nxe:label="Unallocated hero item bank size" nxe:gridwidth="200">
		        <xsd:annotation><xsd:documentation>null = unlimited.</xsd:documentation></xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="unitSettingID" type="momimecommon:unitSettingID" use="optional" nxe:label="Unit Setting ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="spellSetting">
        <xsd:annotation>
        	<xsd:documentation>Defines spell settings that must be supplied when creating a new game.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="switchResearch" type="momimecommon:switchResearch" nxe:label="Switch spell research?" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksToObtainFirstReduction" type="momimecommon:spellBookCount" nxe:label="Spell books to obtain first reduction" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksCastingReduction" type="momimecommon:percentage" nxe:label="% casting reduction from each book" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksCastingReductionCap" type="momimecommon:castingReductionCap" nxe:label="% casting reduction cap" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksCastingReductionCombination" type="momimecommon:castingReductionCombination" nxe:label="Casting reduction combination rule" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksResearchBonus" type="momimecommon:percentage" nxe:label="% research bonus from each book" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksResearchBonusCap" type="momimecommon:castingReductionCap" nxe:label="% research bonus cap" nxe:gridwidth="200" />
			<xsd:element minOccurs="1" maxOccurs="1" name="spellBooksResearchBonusCombination" type="momimecommon:castingReductionCombination" nxe:label="Research bonus combination rule" nxe:showmaincolumn="false" />
		</xsd:sequence>
		<xsd:attribute name="spellSettingID" type="momimecommon:spellSettingID" use="optional" nxe:label="Spell Setting ID" nxe:gridwidth="120" />
	</xsd:complexType>

	<xsd:complexType name="newGameDefaults">
        <xsd:annotation>
        	<xsd:documentation>Default map size, difficulty level and so on to preselect on the new game screen.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultOverlandMapSizeID" type="momimecommon:overlandMapSizeID" nxe:label="Default Overland Map Size" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultLandProportionID" type="momimecommon:landProportionID" nxe:label="Default Land Proportion" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultNodeStrengthID" type="momimecommon:nodeStrengthID" nxe:label="Default Node Strength" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultDifficultyLevelID" type="momimecommon:difficultyLevelID" nxe:label="Default Difficulty Level" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultFogOfWarSettingID" type="momimecommon:fogOfWarSettingID" nxe:label="Default Fog of War Settings" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultUnitSettingID" type="momimecommon:unitSettingID" nxe:label="Default Unit Settings" />
			<xsd:element minOccurs="0" maxOccurs="1" name="defaultSpellSettingID" type="momimecommon:spellSettingID" nxe:label="Default Spell Settings" />
		</xsd:sequence>
	</xsd:complexType>

<!-- Types used in the client side database that it sends to each client as they join a session -->

	<xsd:complexType name="plane" nxe:singular="Plane" nxe:plural="Planes" nxe:submenu="Overland Map">
        <xsd:annotation>
        	<xsd:documentation>Defines the multiple planes/worlds.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="prerequisitePickToChooseNativeRace" type="momimecommon:pickID" nxe:label="Pre-requisite Pick to choose native race from this Plane" nxe:gridwidth="300">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="fortressPlaneProduction" type="momimecommon:productionTypeAndDoubledValue">
		        <xsd:annotation>
		        	<xsd:documentation>Models that a Wizards' Fortress on Myrror generates +5 magic power.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="planeNumber" type="momimecommon:planeNumber" use="required" nxe:label="Plane Number" nxe:gridwidth="80" />
	</xsd:complexType>

	<xsd:complexType name="productionType" nxe:singular="Production Type" nxe:plural="Production Types" nxe:submenu="Cities">
        <xsd:annotation>
        	<xsd:documentation>Defines the different types of production/resources in the game, e.g. Rations, Gold, Magic Power, which are stored up between turns, and what values we must maintain, 
e.g. we can have negative Gold per turn as long as the accumulated amount stays above zero, but we Rations per turn must stay above zero.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="roundingDirectionID" type="momimecommon:roundingDirectionID" nxe:label="Rounding Direction for production from Cities" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="1" maxOccurs="1" name="isPercentage" type="xsd:boolean" nxe:label="Percentage?" nxe:gridwidth="80" />
			<xsd:element minOccurs="0" maxOccurs="1" name="enforceProduction" type="momimecommon:enforceProductionID" nxe:label="Enforce?" nxe:showmaincolumn="false" />
		</xsd:sequence>
		<xsd:attribute name="productionTypeID" type="momimecommon:productionTypeID" use="required" nxe:label="Production Type ID" nxe:gridwidth="110" />
	</xsd:complexType>

	<xsd:complexType name="mapFeature" nxe:singular="Map Feature" nxe:plural="Map Features" nxe:submenu="Overland Map">
        <xsd:annotation>
        	<xsd:documentation>Defines features that can appear on the map on top of the regular terrain, e.g. Gems, Coal, Adamantium, Wild Game, Towers of Wizardry and Monster Lairs.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="canBuildCity" type="xsd:boolean" nxe:label="Can Build City on this Feature?" nxe:gridwidth="180" />
			<xsd:element minOccurs="0" maxOccurs="1" name="featureSpellProtection" type="xsd:boolean" nxe:label="Protects from Spells?" nxe:gridwidth="120" />
			<xsd:element minOccurs="0" maxOccurs="1" name="featureMagicWeapons" type="momimecommon:weaponGradeNumber" nxe:label="Magic Weapons?" nxe:showmaincolumn="false" nxe:gridwidth="150">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>weaponGradeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="raceMineralMultiplerApplies" type="xsd:boolean" nxe:label="Race Mineral Multipler Applies?" nxe:gridwidth="200" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="mapFeatureProduction" type="momimecommon:productionTypeAndDoubledValue">
		        <xsd:annotation>
		        	<xsd:documentation>Defines the types of production that a particular map feature generates, e.g. +5 Gold from Gems, +2 Magic Power from Adamantium.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="mapFeatureID" type="momimecommon:mapFeatureID" use="required" nxe:label="Map Feature ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="tileType" nxe:singular="Tile Type" nxe:plural="Tile Types" nxe:submenu="Overland Map">
        <xsd:annotation>
        	<xsd:documentation>Defines the types of terrain tiles that make up the map, e.g. Grassland, Forest, Mountains, Ocean, Nodes, plus some special entries which aren't really "terrain" - roads and fog of war - for defining movement rate rules.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="land" type="xsd:boolean" nxe:label="Is Solid Land?" nxe:gridwidth="80" />
			<xsd:element minOccurs="0" maxOccurs="1" name="productionBonus" type="momimecommon:percentage" nxe:label="Production Bonus %" nxe:gridwidth="120" />
			<xsd:element minOccurs="0" maxOccurs="1" name="goldBonus" type="momimecommon:percentage" nxe:label="Gold Bonus %" nxe:gridwidth="90" />
			<xsd:element minOccurs="0" maxOccurs="1" name="goldBonusSurroundingTiles" type="xsd:boolean" nxe:label="Gold Bonus from Surrounding Tiles?" nxe:gridwidth="200" />
			<xsd:element minOccurs="0" maxOccurs="1" name="doubleFood" type="momimecommon:doubledProductionValue" nxe:label="2x Food Harvest from Tile" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="1" name="canBuildCity" type="xsd:boolean" nxe:label="Can Build City on this Terrain?" nxe:gridwidth="180" />
			<xsd:element minOccurs="0" maxOccurs="1" name="magicRealmID" type="momimecommon:pickID" nxe:label="Fill with Monsters" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="tileTypeID" type="momimecommon:tileTypeID" use="required" nxe:label="Tile Type ID" nxe:gridwidth="80" />
	</xsd:complexType>

	<xsd:complexType name="pickType" nxe:singular="Type of Spell Pick" nxe:plural="Types of Spell Pick" nxe:submenu="Magic">
        <xsd:annotation>
        	<xsd:documentation>Defines types of picks that can be chosen at the start of the game, i.e. Spell Books &amp; Retorts.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="maximumQuantity" nxe:label="Max. Quantity" type="momimecommon:pickTypeCount">
		        <xsd:annotation>
		        	<xsd:documentation>Retorts can only be picked once; books have no such limit so have a null here.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="fortressPickTypeProduction" type="momimecommon:productionTypeAndDoubledValue">
		        <xsd:annotation>
		        	<xsd:documentation>Models that a Wizards' Fortress generates +2 magic power for each spell book the wizard has.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="pickTypeID" type="momimecommon:pickTypeID" use="required" nxe:label="Pick Type ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="pick" nxe:singular="Pick" nxe:plural="Picks" nxe:submenu="Magic">
        <xsd:annotation>
        	<xsd:documentation>Defines different picks that can be chosen at the start of the game, i.e. the 5x types of Spell Books &amp; different Retorts.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="pickType" type="momimecommon:pickTypeID" nxe:label="Pick Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickTypeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="pickCost" type="momimecommon:pickCost" nxe:label="Cost" nxe:gridwidth="60" />
			<xsd:element minOccurs="0" maxOccurs="1" name="pickReligiousBuildingBonus" type="momimecommon:percentage" nxe:label="Religious Building Bonus %" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="1" name="pickMagicWeapons" type="momimecommon:weaponGradeNumber" nxe:label="Magic Weapons?" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>weaponGradeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitTypeID" type="momimecommon:unitTypeID" nxe:label="Unit Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitTypeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="castSpellsFromPickID" type="momimecommon:pickID" nxe:label="Caster skill (unit) casts spells of which pick?" nxe:gridwidth="300" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="pickPrerequisite" type="momimecommon:pickPrerequisite" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="pickExclusiveFrom" type="momimecommon:pickExclusiveFrom" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="pickProductionBonus" type="momimecommon:pickProductionBonus" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="mergedFromPick" type="momimecommon:mergedFromPick" />
		</xsd:sequence>
		<xsd:attribute name="pickID" type="momimecommon:pickID" use="required" nxe:label="Pick ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="pickPrerequisite" nxe:singular="Pick Pre-requisite" nxe:plural="Pick Pre-requisites">
        <xsd:annotation>
        	<xsd:documentation>Defines pre-requisites for choosing a particular pick at the start of the game, e.g. that you need 4 Life Books to pick Divine Power.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:choice minOccurs="1" maxOccurs="1" >
				<xsd:element minOccurs="0" maxOccurs="1" name="prerequisiteID" type="momimecommon:pickID" nxe:label="Pre-requisite Pick" nxe:gridwidth="100">
					<xsd:annotation>
						<xsd:appinfo>
							<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
						</xsd:appinfo>
					</xsd:annotation>
				</xsd:element>
				<xsd:element minOccurs="0" maxOccurs="1" name="prerequisiteTypeID" type="momimecommon:pickTypeID" nxe:label="Pre-requisite Type" nxe:gridwidth="100" />
			</xsd:choice>
			<xsd:element minOccurs="1" maxOccurs="1" name="prerequisiteCount" type="momimecommon:prerequisiteCount" nxe:label="Count" nxe:gridwidth="60" />
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="pickExclusiveFrom" nxe:singular="Pick Exclusive From Pick" nxe:plural="Pick Exclusive From Picks">
        <xsd:annotation>
        	<xsd:documentation>This models that both Life and Death books cannot be chosen together.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="pickExclusiveFromID" type="momimecommon:pickID" use="required" nxe:label="Exclusive From ID" nxe:gridwidth="150">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="pickProductionBonus" nxe:singular="Pick Production Bonus" nxe:plural="Pick Production Bonuses">
        <xsd:annotation>
        	<xsd:documentation>Models production bonuses from retorts, e.g. Archmage +50% on magic power spent on skill, Sage Master +25% research bonus.  Can apply to specific unit types (e.g. Summoner) or magic realms (e.g. Chaos Mastery).</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="magicRealmID" type="momimecommon:pickID" nxe:label="Magic Realm" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="magicRealmIdBlank" type="xsd:boolean" nxe:label="Magic Realm must be blank (Arcane)?" />
			<xsd:element minOccurs="0" maxOccurs="1" name="itemCraftingSpells" type="xsd:boolean" nxe:label="Affects only item crafting spells?" />
			<xsd:element minOccurs="0" maxOccurs="1" name="unitTypeID" type="momimecommon:unitTypeID" nxe:label="Unit Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitTypeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="percentageBonus" type="momimecommon:percentage" nxe:label="% bonus" nxe:gridwidth="80" />
		</xsd:sequence>
		<xsd:attribute name="productionTypeID" type="momimecommon:productionTypeID" use="required" nxe:label="Production Type ID" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>productionTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="mergedFromPick" nxe:singular="Merged from pick" nxe:plural="Merged from picks">
        <xsd:annotation>
        	<xsd:documentation>This is for modelling units that are both Undead and Chaos Channeled.  So LTUC = LTU + LTC.
When the code is checking for skills that modify a unit's magic realm/lifeform type, if it finds only one then that one becomes its modified magic realm/lifeform type.
If it finds multiple, it will look for a pick with mergedFromPick entries that match the list.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="mergedFromPickID" type="momimecommon:pickID" use="required" nxe:label="Merged from pick" nxe:gridwidth="150">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="wizard" nxe:singular="Wizard" nxe:plural="Wizards">
        <xsd:annotation>
        	<xsd:documentation>The pre-built wizards and their standard picks.  Human players can choose a pre-built wizard or a custom wizard; AI players will always choose one of the pre-defined wizards.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="wizardID" type="momimecommon:wizardID" use="required" nxe:label="Wizard ID" nxe:gridwidth="80" />
	</xsd:complexType>

	<xsd:complexType name="pickAndQuantity" nxe:singular="Pick" nxe:plural="Picks">
        <xsd:annotation>
        	<xsd:documentation>Stores a pickID and quantity; used in a couple of places with different meanings.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="quantity" type="momimecommon:pickQuantity" nxe:label="Quantity" nxe:gridwidth="80" />
		</xsd:sequence>
		<xsd:attribute name="pickID" type="momimecommon:pickID" use="required" nxe:label="Pick" nxe:gridwidth="80">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					<nxe:showreferencedfield>pickType</nxe:showreferencedfield>
					<nxe:showreferencedfield>pickCost</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="race" nxe:singular="Race" nxe:plural="Races">
        <xsd:annotation>
        	<xsd:documentation>The different races of civilians &amp; units in the game.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="nativePlane" type="momimecommon:planeNumber" nxe:label="Native Plane" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>planeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="growthRateModifier" type="momimecommon:cityPopulationGrowthRate" nxe:label="Growth Rate Modifier" nxe:gridwidth="120" />
			<xsd:element minOccurs="1" maxOccurs="1" name="mineralBonusMultiplier" type="momimecommon:mineralBonusMultiplier" nxe:label="Mineral Bonus Multipler" nxe:gridwidth="130" />
			<xsd:element minOccurs="0" maxOccurs="1" name="goldTradeBonus" type="momimecommon:percentage" nxe:label="Gold Trade Bonus" nxe:gridwidth="130" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="racePopulationTask" type="momimecommon:racePopulationTask">
				<xsd:key name="racePopulationTaskProductionPK">
					<xsd:selector xpath="racePopulationTaskProduction" />
					<xsd:field xpath="@productionTypeID" />
				</xsd:key>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="raceUnrest" type="momimecommon:raceUnrest" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="raceCannotBuild" type="momimecommon:raceCannotBuild" />
		</xsd:sequence>
		<xsd:attribute name="raceID" type="momimecommon:raceID" use="required" nxe:label="Race ID" nxe:gridwidth="80" />
	</xsd:complexType>
	
	<xsd:complexType name="racePopulationTask" nxe:singular="Race Population Task" nxe:plural="Race Population Tasks">
        <xsd:annotation>
        	<xsd:documentation>Defines the characteristics of each population task for a particular race.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="racePopulationTaskProduction" type="momimecommon:productionTypeAndDoubledValue">
		        <xsd:annotation>
		        	<xsd:documentation>Lists the types of production that 1,000 civilians of a particular race performing a particular task produce.  e.g. Defines that
Halfling farmers produce more food, that Klackon and Dwarven workers produce more production, and which races naturally generate magic power.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="populationTaskID" type="momimecommon:populationTaskID" use="required" nxe:label="Population Task ID" nxe:gridwidth="150" />
	</xsd:complexType>

	<xsd:complexType name="raceUnrest" nxe:singular="Unrest" nxe:plural="Unrest">
        <xsd:annotation>
        	<xsd:documentation>For a particular city race, lists out the unrest generated for each possible capital race (the race inhabiting the city where the wizards' fortress is).  Unrest modifier can be a fixed value (Klackons special -2 modifier) or more usually a percentage.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:choice minOccurs="1" maxOccurs="1" >
				<xsd:element minOccurs="0" maxOccurs="1" name="unrestPercentage" type="momimecommon:percentage" nxe:label="Unrest %" nxe:gridwidth="70" />
				<xsd:element minOccurs="0" maxOccurs="1" name="unrestLiteral" type="momimecommon:unrestLiteral" nxe:label="Unrest Literal Amount" nxe:gridwidth="120" />
			</xsd:choice>
		</xsd:sequence>
		<xsd:attribute name="capitalRaceID" type="momimecommon:raceID" use="required" nxe:label="Capital Race ID" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>raceName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="raceCannotBuild" nxe:singular="Race Cannot Build" nxe:plural="Race Cannot Build">
        <xsd:annotation>
        	<xsd:documentation>Lists out all the buildings that a particular race cannot build.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="cannotBuildBuildingID" type="momimecommon:buildingID" use="required" nxe:label="Cannot Build Building ID" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>buildingName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="taxRate" nxe:singular="Tax Rate" nxe:plural="Tax Rates" nxe:submenu="Cities">
        <xsd:annotation>
        	<xsd:documentation>Lists the tax rates players can choose in the game, and how much gold and unrest is generated by each setting.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="doubleTaxGold" type="momimecommon:doubledProductionValue" nxe:label="2x Gold per Population" nxe:gridwidth="140" />
			<xsd:element minOccurs="1" maxOccurs="1" name="taxUnrestPercentage" type="momimecommon:percentage" nxe:label="Unrest %" nxe:gridwidth="80" />
		</xsd:sequence>
		<xsd:attribute name="taxRateID" type="momimecommon:taxRateID" use="required" nxe:label="Tax Rate ID" nxe:gridwidth="80" />
	</xsd:complexType>
	
	<xsd:complexType name="building" nxe:singular="Building" nxe:plural="Buildings" nxe:submenu="Cities">
        <xsd:annotation>
        	<xsd:documentation>All the different buildings that can be constructed in cities, plus a couple of special entries (the special settings Housing &amp; Trade Goods, the Wizards' Fortress and Summoning Circle).</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingUnrestReduction" type="momimecommon:buildingUnrestReduction" nxe:label="Unrest Reduction" nxe:gridwidth="50" />
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingUnrestReductionImprovedByRetorts" type="xsd:boolean" nxe:label="Unrest reduction improved by DivP/InfP?" nxe:gridwidth="220" />
			<xsd:element minOccurs="0" maxOccurs="1" name="growthRateBonus" type="momimecommon:cityPopulationGrowthRate" nxe:label="Growth Rate Bonus" nxe:gridwidth="120" />
			<xsd:element minOccurs="0" maxOccurs="1" name="housingPercentageBonus" type="momimecommon:percentage" nxe:label="Housing %" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingExperience" type="momimecommon:experiencePoints" nxe:label="Experience Granted" nxe:gridwidth="120" />
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingMagicWeapons" type="momimecommon:weaponGradeNumber" nxe:label="Magic Weapons?" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>weaponGradeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="productionCost" type="momimecommon:productionCost" nxe:label="Production Cost" nxe:gridwidth="110" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="buildingPopulationProductionModifier" type="momimecommon:buildingPopulationProductionModifier" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="buildingPrerequisite" type="momimecommon:buildingPrerequisite" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="buildingRequiresTileType" type="momimecommon:buildingRequiresTileType" />
		</xsd:sequence>
		<xsd:attribute name="buildingID" type="momimecommon:buildingID" use="required" nxe:label="Building ID" nxe:gridwidth="65" />
	</xsd:complexType>
	
	<xsd:complexType name="buildingPopulationProductionModifier" nxe:singular="Building Population Production Modifier" nxe:plural="Building Population Production Modifiers">
        <xsd:annotation>
        	<xsd:documentation>Defines all the production, consumption (upkeep) and percentage modifiers for a particular type of buildings, including how much gold the building costs to maintain (task blank), 
Animsts' Guilds increasing farmers' ration production, production boost from Sawmills, and the magic power and research produced by Alchemists' and Sages' Guilds.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="doubleAmount" type="momimecommon:doubledProductionValue" nxe:label="2x Modifier Amount" nxe:gridwidth="120" />
			<xsd:element minOccurs="0" maxOccurs="1" name="percentageBonus" type="momimecommon:percentage" nxe:label="Percentage Bonus" nxe:gridwidth="100" />
		</xsd:sequence>
		<xsd:attribute name="populationTaskID" type="momimecommon:populationTaskID" use="optional" nxe:label="Population Task ID" nxe:showmaincolumn="false">
	        <xsd:annotation>
	        	<xsd:documentation>Population Task can be ommitted, in which case the modifier applies once to the city as a whole.  If filled in, the modifier applies to each 1,000 civilians performing that task.</xsd:documentation>
	        </xsd:annotation>
        </xsd:attribute>
		<xsd:attribute name="productionTypeID" type="momimecommon:productionTypeID" use="required" nxe:label="Production Type ID" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>productionTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="buildingPrerequisite" nxe:singular="Building Pre-requisite" nxe:plural="Building Pre-requisites">
        <xsd:annotation>
        	<xsd:documentation>For a particular building, defines the buildings you must already have in order to construct it, e.g. to build a Farmers' Market you must have a Granary and a Marketplace.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="prerequisiteID" type="momimecommon:buildingID" use="required" nxe:label="Building Pre-requisite" nxe:gridwidth="150">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>buildingName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="buildingRequiresTileType" nxe:singular="Tile Type Pre-requisite" nxe:plural="Tile Type Pre-requisites">
        <xsd:annotation>
        	<xsd:documentation>For a particular building, specifies if you can only construct this building if there is a particular type of tile within a particular radius, e.g. can only build a Ship Wrights' Guild if there is an adjacent Ocean tile, and can only build a Sawmill if there is some Forest in the city radius.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="distance" type="momimecommon:integerMapDistance" nxe:label="Distance" nxe:gridwidth="80" />
		</xsd:sequence>
		<xsd:attribute name="tileTypeID" type="momimecommon:tileTypeID" use="required" nxe:label="Tile Type Pre-requisite" nxe:gridwidth="150">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>tileTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="rangedAttackType" nxe:singular="Ranged Attack Type" nxe:plural="Ranged Attack Types" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Lists all the different types of ranged attacks available, e.g. arrows, rocks, lightning bolts (Storm Giants), purple dots (Dark Elves).  Magic ranged attacks are of a particular magic realm, which is important for spells which resist against particular realms of magic, e.g. Elemental Armour.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="magicRealmID" type="momimecommon:pickID" nxe:label="Magic Realm (for e.g. Elem Armour &amp; Righteousness)" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:documentation>Non-magical ranged attacks (such as arrows and rocks) do not have a magic realm ID.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="mithrilAndAdamantiumVersions" type="xsd:boolean" nxe:label="Mithril/Adam?" />
		</xsd:sequence>
		<xsd:attribute name="rangedAttackTypeID" type="momimecommon:rangedAttackTypeID" use="required" nxe:label="RAT ID" nxe:gridwidth="50" />
	</xsd:complexType>

	<xsd:complexType name="weaponGrade" nxe:singular="Weapon Grade" nxe:plural="Weapon Grades" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Defines the wepaon grades available for normal units, such as that units can have Adamantium instead of regular weapons.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="weaponGradeSkillBonus" type="momimecommon:unitSkillAndValue" />
		</xsd:sequence>
		<xsd:attribute name="weaponGradeNumber" type="momimecommon:weaponGradeNumber" use="required" nxe:label="Weapon Grade Number" nxe:gridwidth="120" />
	</xsd:complexType>

	<xsd:complexType name="unitSkill" nxe:singular="Unit Skill" nxe:plural="Unit Skills" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Defines all the unit attributes and skills available, e.g. Melee Attack Strength, Defence, Resistance, First Strike, Flame Breath,
Flying, Scouting, as well as skill-like effects from spells (both enchantments and curses), e.g. Bless, Endurance, Flame Blade, Confusion, Black Sleep -
i.e. both the lists of top half and bottom half of the unit info screen.  Their only difference is where they appear on the unit info screen, which
is defined in the graphics XML file.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="changesUnitToMagicRealm" type="momimecommon:pickID" nxe:label="Changes Unit to Magic Realm/Lifeform Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="ignoreCombatTerrain" type="xsd:boolean" nxe:label="Ignore combat terrain?">
		        <xsd:annotation>
		        	<xsd:documentation>If a unit has any skill where this is set to true, they will not be hindered by combat terrain that slows movement, such as
ridges or the Earth to Mud skill.  They also don't gain the benefit of faster movement from roads.  It also allows them to ignore combat tile borders
that normally block movement across them (i.e. stone walls).  Completely impassable tiles such as buildings or stone wall corner sections are still impassable.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="addsToSkill" type="momimecommon:addsToSkill" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="grantsSkill" type="momimecommon:grantsSkill" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="negatedBySkill" type="momimecommon:negatedBySkill" />
		</xsd:sequence>
		<xsd:attribute name="unitSkillID" type="momimecommon:unitSkillID" use="required" nxe:label="Unit Skill ID" nxe:gridwidth="80" />
	</xsd:complexType>

	<xsd:complexType name="addsToSkill" nxe:singular="Adds to Skill" nxe:plural="Adds to Skills">
		<xsd:annotation>
			<xsd:documentation>Defines when having one skill adds some bonus value to another skill.  This includes hero skills,
e.g. Agility adds to the hero's Defence score, and spell effects e.g. Holy Armour also adds to the unit's Defence score.
A single skill can add a bonus to multiple skills, as is the case with Holy Bonus.  There is no unique key here - it would in theory be
possible to define one skill that adds say +2 defence to ourselves, but +1 to all other units in our stack, so addsToSkillID may be repeated.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="addsToSkillID" type="momimecommon:unitSkillID" nxe:label="Adds to Skill">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="affectsEntireStack" type="xsd:boolean" nxe:label="Affects entire stack?" nxe:gridwidth="150">
		        <xsd:annotation>
        			<xsd:documentation>Usually false.  Set to true if a unit possessing this skill provides the bonus to the entire stack as well as this unit.
Used for Resistance to All and Holy Bonus.  Note in the original MoM, such skills only worked inside combat.</xsd:documentation>
        		</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="addsToSkillDivisor" type="momimecommon:skillDivisor" nxe:label="Skill Level Divisor" nxe:gridwidth="100">
		        <xsd:annotation>
        			<xsd:documentation>This is for hero skills, where the amount of bonus added depends on the level of the hero.  It is 1 for most hero skills,
e.g. Agility adds Level / 1 to the hero's Defence score; the exception is Blademaster which only adds Level / 2 to the hero's +to Hit score.
If addsToSkillID is non-null, either addsToSkillDivisor or addsToSkillFixed must be filled in, but not both.  If both are null, the amount of the
bonus is taken from the numeric value of the skill, e.g. "Resistance to Others 2".</xsd:documentation>
        		</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="addsToSkillFixed" type="momimecommon:unitSkillValue" nxe:label="Skill Fixed Bonus" nxe:gridwidth="100">
		        <xsd:annotation>
        			<xsd:documentation>This is typically for spell effects, where a fixed amount is added to another skill, e.g. Holy Armour adds +2 to Defence.
If addsToSkillID is non-null, either addsToSkillDivisor or addsToSkillFixed must be filled in, but not both.  If both are null, the amount of the
bonus is taken from the numeric value of the skill, e.g. "Resistance to Others 2".</xsd:documentation>
        		</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="rangedAttackTypeID" type="momimecommon:rangedAttackTypeID" nxe:label="Ranged attack type" nxe:showmaincolumn="false">
				<xsd:annotation>
        			<xsd:documentation>This is principally here for the "Flame Blade" skill, which only gives +2 ranged attack for certain RATs but not others.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>rangedAttackTypeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="onlyVersusAttacksFromSkillID" type="momimecommon:unitSkillID" nxe:label="Only applies vs atks from skill" nxe:showmaincolumn="false">
				<xsd:annotation>
        			<xsd:documentation>This is principally here for the "Large Shield" skill, which only gives +2 defence vs. incoming ranged attacks, but not melee.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="negateOnlyVersusAttacksFromSkillID" type="xsd:boolean" nxe:label="Not?" nxe:gridwidth="50">
				<xsd:annotation>
        			<xsd:documentation>Inverts the onlyVersusAttacksFromSkillID check, so will grant bonus if skill is NOT one of those listed.
This is principally here for the ""Large Shield", which is defined as "gives +2 defence vs. all types of incoming attack except melee hits".</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="onlyVersusAttacksFromMagicRealmID" type="momimecommon:pickID" nxe:label="Only applies vs atks from magic realm" nxe:showmaincolumn="false">
				<xsd:annotation>
        			<xsd:documentation>Some spell effects, e.g. Resist Elements or Bless, only provide a stat bonus when the unit is attacked by certain realms of magic.
In that case, the restriction is put here, with multiple addsToSkill records if necessary.  A null here means the bonus always applies no matter the kind of attack.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="grantsSkill" nxe:singular="Grants Skill" nxe:plural="Grants Skills">
		<xsd:annotation>
			<xsd:documentation>Certain skills implicitly grant other skills, e.g. Invulerability and Wraith Form both implicitly grant Weapon Immunity.
But we can't just duplicate the Weapon Immunity effect because a unit with magical weapons ignores the Weapon Immunity portion of the skill but not the -2 damage portion.
So like this, its possible to basically break skills down into multiple sub-skills, with different immunities to each.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="grantsSkillID" type="momimecommon:unitSkillID" use="required" nxe:label="Grants Skill" nxe:gridwidth="100">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="negatedBySkill" nxe:singular="Negated by Skill" nxe:plural="Negated by Skills">
		<xsd:annotation>
			<xsd:documentation>Certain skills cancel each other out, e.g. under First Strike will be a negation record listing the Negate First Strike cancels it out,
and under Resist Elements will be a negation record listing that Elemental Armour cancels it out.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="negatedBySkillID" type="momimecommon:unitSkillID" nxe:label="Negated by Skill">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="negatedByUnitID" type="momimecommon:negatedByUnitID" nxe:label="Negated by which unit's skill?" nxe:showmaincolumn="false" />
		</xsd:sequence>
	</xsd:complexType>
	
	<xsd:complexType name="unitType" nxe:singular="Unit Type" nxe:plural="Unit Types" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Defines the types of units in the game, i.e. Normal, Summoned and Heroes.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="undeadUpkeepPercentage" type="xsd:unsignedShort" nxe:label="Undead upkeep %" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="experienceLevel" type="momimecommon:experienceLevel" />
		</xsd:sequence>
		<xsd:attribute name="unitTypeID" type="momimecommon:unitTypeID" use="required" nxe:label="Unit Type ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="experienceLevel" nxe:singular="Experience Level" nxe:plural="Experience Levels">
        <xsd:annotation>
        	<xsd:documentation>Defines the different experience levels a particular type of unit can attain.  Normal units and Heroes have different experience tables; Summoned units don't gain experience at all.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="experienceRequired" type="momimecommon:experiencePoints" nxe:label="Experience Required" nxe:gridwidth="150">
				<xsd:annotation>
					<xsd:documentation>experienceRequired is omitted for experience levels that cannot be attained simply by gaining experience, i.e. Ultra-Elite and Champion on Normal units (which need Warlord and/or Crusade to attain).
Levels that do not require any experience (i.e. Recruit for normal units) must state a 0 here and not leave the field blank.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="ringColour" type="momimecommon:colour" nxe:label="Ring Colour" nxe:gridwidth="80" />
			<xsd:element minOccurs="1" maxOccurs="1" name="ringCount" type="momimecommon:experienceLevelRingCount" nxe:label="Nbr. Rings" nxe:gridwidth="70" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="experienceSkillBonus" type="momimecommon:unitSkillAndValue" />
		</xsd:sequence>
		<xsd:attribute name="levelNumber" type="momimecommon:experienceLevelNumber" use="required" nxe:label="Level" nxe:gridwidth="50" />
	</xsd:complexType>

	<xsd:complexType name="unit" nxe:singular="Unit" nxe:plural="Units" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Defines all the units available in the game.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="unitMagicRealm" type="momimecommon:pickID" nxe:label="Magic Realm/Lifeform Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitRaceID" type="momimecommon:raceID" nxe:label="Unit Race" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>raceName</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="includeRaceInUnitName" type="xsd:boolean" nxe:label="Race in Unit Name?" nxe:gridwidth="110" />
			<xsd:element minOccurs="1" maxOccurs="1" name="figureCount" type="momimecommon:figureCount" nxe:label="Figure Count" nxe:gridwidth="80" />
			<xsd:element minOccurs="0" maxOccurs="1" name="productionCost" type="momimecommon:productionCost" nxe:label="Cost" nxe:gridwidth="50">
				<xsd:annotation>
					<xsd:documentation>Production cost is optional; units with no production cost are assumed to be infinitely expensive and so can not be 'built' in any conventional manner or put in
nodes/lairs/towers, however they can still be created from summoning spells (whose cost is set by the casting cost of the spell, not the production cost of the unit).
This is used to stop the server putting Floating Islands in Sorcery Nodes.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="rangedAttackType" type="momimecommon:rangedAttackTypeID" nxe:label="Ranged Type" nxe:gridwidth="80">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>rangedAttackTypeDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="transportCapacity" type="momimecommon:transportCapacity" nxe:label="Transport Capacity" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitUpkeep" type="momimecommon:productionTypeAndUndoubledValue">
				<xsd:annotation>
					<xsd:documentation>Lists all the types of upkeep for a particular unit, e.g. that Wolf Riders eat 1 ration and use 2 gold per turn.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitPrerequisite" type="momimecommon:unitPrerequisite" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitHasSkill" type="momimecommon:unitSkillAndValue" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemSlot" type="momimecommon:heroItemSlot" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitCanCast" type="momimecommon:unitCanCast" />
		</xsd:sequence>
		<xsd:attribute name="unitID" type="momimecommon:unitID" use="required" nxe:label="Unit ID" nxe:gridwidth="50" />
	</xsd:complexType>

	<xsd:complexType name="unitCanCast" nxe:singular="Unit Spell" nxe:plural="Unit Spells">
        <xsd:annotation>
        	<xsd:documentation>Defines fixed spells a particular unit can cast - Priests casting Healing, Magicians casting Fireball, Warlocks casting Doom Bolt, and Giant Spiders "casting" Web.
Heroes have entries with numberOfTimes left null for the additional spells they know, e.g. Serena the Healer always knows the Healing spell even if her controlling wizard doesn't.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="numberOfTimes" type="momimecommon:spellCount" nxe:label="Number of Times can cast it" nxe:gridwidth="200" />
		</xsd:sequence>
		<xsd:attribute name="unitSpellID" type="momimecommon:spellID" use="required" nxe:label="Spell" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>spellName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="unitSkillAndValue" nxe:singular="Unit Skills" nxe:plural="Unit Skills">
        <xsd:annotation>
        	<xsd:documentation>Specifies that a unit has a particular skill, or some skill bonus granted from experience, items or so on.
This type is reused in a lot of places.  Some skills are valueless, e.g. First Strike or Flying, while others specify some kind of strength value, e.g. Flame Breath or Scouting.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitSkillValue" type="momimecommon:unitSkillValue" nxe:label="Skill Value" nxe:gridwidth="100">
				<xsd:annotation>
					<xsd:documentation>Some skills have a value or saving throw penalty (such as Fire Breath 2 or Fire Breath 20, or Life Steal 2 or Life Steal 6) whereas some skills
don't have a value (such as Fire Immunity or Mountaineer).  By convention MoM IME stores all skill values as positive numbers.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="unitSkillID" type="momimecommon:unitSkillID" use="required" nxe:label="Skill" nxe:gridwidth="200">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="productionTypeAndUndoubledValue" nxe:singular="Undoubled Production" nxe:plural="Undoubled Production">
        <xsd:annotation>
        	<xsd:documentation>Stores a production type ID and value.  Note this is an identical structure to productionTypeAndDoubledValue
but kept these separate to make it totally clear when production values are recorded as is and when they are recorded doubled.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="undoubledProductionValue" type="momimecommon:undoubledProductionValue" nxe:label="Undoubled value" nxe:gridwidth="150" />
		</xsd:sequence>
		<xsd:attribute name="productionTypeID" type="momimecommon:productionTypeID" use="required" nxe:label="Production Type" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>productionTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="productionTypeAndDoubledValue" nxe:singular="Doubled Production" nxe:plural="Doubled Production">
        <xsd:annotation>
        	<xsd:documentation>Stores a production type ID and value.  Note this is an identical structure to productionTypeAndUndoubledValue
but kept these separate to make it totally clear when production values are recorded as is and when they are recorded doubled.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="doubledProductionValue" type="momimecommon:doubledProductionValue" nxe:label="Doubled value" nxe:gridwidth="150" />
		</xsd:sequence>
		<xsd:attribute name="productionTypeID" type="momimecommon:productionTypeID" use="required" nxe:label="Production Type" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>productionTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="unitPrerequisite" nxe:singular="Unit Pre-requisite" nxe:plural="Unit Pre-requisites">
        <xsd:annotation>
        	<xsd:documentation>Lists the buildings that we need to have in a city in order to build a particular unit, e.g. that we need a Sawmill to build Bowmen.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="prerequisiteID" type="momimecommon:buildingID" use="required" nxe:label="Unit Pre-requisite" nxe:gridwidth="150">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>buildingName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>
	
	<xsd:complexType name="combatAreaEffect" nxe:singular="Combat Area Effect" nxe:plural="Combat Area Effects" nxe:submenu="Magic">
        <xsd:annotation>
        	<xsd:documentation>Defines area effects that affect an entire combat, or the entire map, e.g. Prayer, Darkness, Crusade, Eternal Night and Node Auras.
"Affects Players" is null for CAEs that don't modify unit stats, e.g. Counter Magic or the dispelling auras of nodes.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="combatAreaAffectsPlayers" type="momimecommon:combatAreaAffectsPlayersID" nxe:label="Bonuses apply to units belonging to" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>combatAreaEffectsPlayersDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="combatAreaEffectSkillBonus" type="momimecommon:combatAreaEffectSkillBonus" />
		</xsd:sequence>
		<xsd:attribute name="combatAreaEffectID" type="momimecommon:combatAreaEffectID" use="required" nxe:label="Effect ID" nxe:gridwidth="80" />
	</xsd:complexType>

	<xsd:complexType name="combatAreaEffectSkillBonus" nxe:singular="Skill Bonus" nxe:plural="Skill Bonuses">
        <xsd:annotation>
        	<xsd:documentation>Lists the bonuses or penalties to skills that units get from a particular combat area effect, e.g. Chaos creatures getting bonuses to the "attack" type skills such as Fire Breath from Chaos nodes.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
			<xsd:extension base="momimecommon:unitSkillAndValue">
				<xsd:sequence>
					<xsd:element minOccurs="0" maxOccurs="1" name="effectMagicRealm" type="momimecommon:pickID" nxe:label="Bonus applies to creatures of magic realm" nxe:showmaincolumn="false">
						<xsd:annotation>
							<xsd:appinfo>
								<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
							</xsd:appinfo>
						</xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="spell" nxe:singular="Spell" nxe:plural="Spells" nxe:submenu="Spells">
        <xsd:annotation>
        	<xsd:documentation>Defines all the spells available to research and cast.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="spellRealm" type="momimecommon:pickID" nxe:label="Realm" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:documentation>'Arcane' is not defined as a spell realm in MoM IME, so spells are defined as Arcane by leaving off the spellRealm element.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="spellRank" type="momimecommon:spellRankID" nxe:label="Rank" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="0" maxOccurs="1" name="researchCost" type="momimecommon:spellResearchCost" nxe:label="Research Cost" nxe:gridwidth="100">
				<xsd:annotation>
					<xsd:documentation>Arcane spells with no research cost defined (or research cost specified as zero) are given to the player for free at the start of the game, i.e. Magic Spirit and the Spell of Return.  See TMomServerPlayer.PutAllArcaneSpellsIntoSpellBook.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="overlandCastingCost" type="momimecommon:spellCastingCost" nxe:label="Overland Cost" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="1" name="combatCastingCost" type="momimecommon:spellCastingCost" nxe:label="Combat Cost" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="1" name="spellBookSectionID" type="momimecommon:spellBookSectionID" nxe:label="Spell Book Section" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="0" maxOccurs="1" name="permanent" type="xsd:boolean" nxe:label="Permanent?" nxe:gridwidth="100">
		        <xsd:annotation>
		        	<xsd:documentation>Permanent spells can never be switched off by any means, either voluntarily by the caster or via dispel-type spells.  Used for Chaos Channels.
(This implies that the spell should have 0 upkeep cost, or the client could get into a deadlock where it won't let you end turn because you don't have enough mana to pay for
spell upkeep, but cannot switch off the spell that's costing the upkeep)</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingID" type="momimecommon:buildingID" nxe:label="Building Created" nxe:showmaincolumn="false">
				<xsd:annotation>
		        	<xsd:documentation>Indicates the building that this spell creates.  Used for: Wall of Stone, Summoning Circle and Move Fortress.</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>buildingName</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="resurrectedHealthPercentage" type="momimecommon:percentage" nxe:label="Resurrected health %">
				<xsd:annotation>
		        	<xsd:documentation>Indicates that this is a raise dead-type spell, and the unit comes back with this much health.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="resurrectEnemyUnits" type="xsd:boolean" nxe:label="Resurrect enemy units?">
				<xsd:annotation>
		        	<xsd:documentation>Animate dead can be used to resurrect (and hence steal) enemy units; Raise dead cannot.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="resurrectingAddsSkillID" type="momimecommon:unitSkillID" nxe:label="Resurrecting adds skill" nxe:showmaincolumn="false">
				<xsd:annotation>
		        	<xsd:documentation>Skill added to resurrected units (Animate Dead adds the Undead "skill").</xsd:documentation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="attackSpellCombatTarget" type="momimecommon:attackSpellCombatTargetID" nxe:label="Atk Spell Combat Target" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="0" maxOccurs="1" name="attackSpellDamageTypeID" type="momimecommon:damageTypeID" nxe:label="Damage Type" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>damageTypeName</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="attackSpellDamageResolutionTypeID" type="momimecommon:damageResolutionTypeID" nxe:label="Damage Res. Type" nxe:showmaincolumn="false" />
			<xsd:element minOccurs="0" maxOccurs="1" name="combatBaseDamage" type="momimecommon:unitSkillValue" nxe:label="Combat Base Dmg" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="1" name="combatMaxDamage" type="momimecommon:unitSkillValue" nxe:label="Combat Max Dmg" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="1" name="combatManaPerAdditionalDamagePoint" type="momimecommon:spellCastingCost" nxe:label="MP per +1 dmg" nxe:gridwidth="100">
		        <xsd:annotation>
		        	<xsd:documentation>The usual case is that it costs several mana to raise the damage by 1 point, in which case a value is set here.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="combatAdditionalDamagePointsPerMana" type="momimecommon:unitSkillValue" nxe:label="Dmg per +1 MP" nxe:gridwidth="100">
		        <xsd:annotation>
		        	<xsd:documentation>The rare case where a single 1 mana is enough to boost damage by more than 1 point.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="heroItemBonusMaximumCraftingCost" type="momimecommon:spellCastingCost" nxe:label="Item Bonus Max Cost" nxe:gridwidth="150">
		        <xsd:annotation>
		        	<xsd:documentation>For summoning spells, identifies that the spell summons hero items (i.e. Enchant Item or Create Artifact).  The value indicates the most
expensive bonus we are allowed to put onto the item.  A value of 0 allows all bonuses.  Spell Charges are only allowed if the value is 0.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="spellScoutingRange" type="momimecommon:scoutingRange" nxe:label="Scouting Range" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="summonedUnit" type="momimecommon:summonedUnit" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitSpellEffect" type="momimecommon:unitSpellEffect" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellHasCityEffect" type="momimecommon:spellHasCityEffect" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellHasCombatEffect" type="momimecommon:spellHasCombatEffect" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellValidUnitTarget" type="momimecommon:spellValidUnitTarget" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellValidBorderTarget" type="momimecommon:spellValidBorderTarget" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellUpkeep" type="momimecommon:productionTypeAndUndoubledValue">
		        <xsd:annotation>
		        	<xsd:documentation>Defines the upkeep a particular spells costs each turn, typically an amount of mana.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
		</xsd:sequence>
		<xsd:attribute name="spellID" type="momimecommon:spellID" use="required" nxe:label="Spell ID" nxe:gridwidth="60" />
	</xsd:complexType>

	<xsd:complexType name="unitSpellEffect" nxe:singular="Unit Effect" nxe:plural="Unit Effects">
        <xsd:annotation>
        	<xsd:documentation>Lists the possible unit skill(s) granted from casting a unit enchantment/curse on a unit.
Normally there's only 1; 3 in the case of Chaos Channels or Warp Creature.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
			<xsd:extension base="momimecommon:unitSkillAndValue">
				<xsd:sequence>
					<xsd:element minOccurs="0" maxOccurs="1" name="permanent" type="xsd:boolean" nxe:label="Permanent?">
				        <xsd:annotation>
				        	<xsd:documentation>If true, this spell effect is added disconnected from the spell that it came from.  Thus can never be removed.
This is used for the fact that Black Channels turns units Undead, and while the Black Channels effect can be switched off, the Undead effect cannot.</xsd:documentation>
				        </xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="summonedUnit" nxe:singular="Summoned Unit" nxe:plural="Summoned Units">
        <xsd:annotation>
        	<xsd:documentation>For summoning spells, defines all possible units that can be summoned by the spell.  When a player casts the spell, one of the listed units will be chosen at random and summoned.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="summonedUnitID" type="momimecommon:unitID" use="required" nxe:label="Option for Summoned Unit" nxe:gridwidth="200">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>unitName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="spellHasCityEffect" nxe:singular="City Spell Effect" nxe:plural="City Spell Effects">
        <xsd:annotation>
        	<xsd:documentation>For city enchantments and curses, defines all possible city spell effects the spell can grant.  Unlike unit spell effects, which city spell effect can be chosen by the player when they cast the spell, rather than randomly.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="citySpellEffectID" type="momimecommon:citySpellEffectID" use="required" nxe:label="Option for City Spell" nxe:gridwidth="200" />
	</xsd:complexType>

	<xsd:complexType name="spellHasCombatEffect" nxe:singular="Combat Area Effect" nxe:plural="Combat Area Effects">
        <xsd:annotation>
        	<xsd:documentation>For combat enchantments, defines all possible combat area effects the spell can grant.  Technically one is chosen at random when the spell is cast, however there's no spells in the original MoM with multiple possible combat area effects.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="combatAreaEffectID" type="momimecommon:combatAreaEffectID" use="required" nxe:label="Effect ID" nxe:gridwidth="80">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>combatAreaEffectDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="spellValidUnitTarget" nxe:singular="Valid Unit Target" nxe:plural="Valid Unit Targets">
        <xsd:annotation>
        	<xsd:documentation>Some spells can only be cast on certain types of unit, e.g. Dispel Evil can only be cast on Chaos &amp; Death creatures, in which case they are listed here.  Also defines saving throw penalties for spells which can be resisted.  
Can have different saving throw depending on the type of unit.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="savingThrowSkillID" type="momimecommon:unitSkillID" nxe:label="Saving Throw rolls against Target Skill" nxe:showmaincolumn="false">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="savingThrowModifier" type="momimecommon:savingThrowModifier" nxe:label="Saving Throw Modifier" nxe:gridwidth="150" />
		</xsd:sequence>
		<xsd:attribute name="targetMagicRealmID" type="momimecommon:pickID" use="optional" nxe:label="Magic Realm/Lifeform Type" nxe:showmaincolumn="false">
			<xsd:annotation>
				<xsd:documentation>If targetMagicRealmID is filled in on any spellValidUnitTarget records under a spell, then the spell can only be cast on units of the specified unit type(s).  e.g. Chaos Channels can only be cast on Normal Units or Heroes, and the
saving throw elements (if present) describe what attribute and penalty each type of unit gets to make saving throw against.  (If no saving throw defined, the target gets no chance to save!)
This is to model spells which have different saving throws for different types of unit, e.g. Dispel Evil and Holy Word have much more severe saving throws against Undead than other types of unit.

If targetMagicRealmID is ommitted, the spell can be cast on all types of unit and has the same saving throw (if any) against all types of unit.</xsd:documentation>
				<xsd:appinfo>
					<nxe:showreferencedfield>pickDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="spellValidBorderTarget" nxe:singular="Valid Border Target" nxe:plural="Valid Border Targets">
        <xsd:annotation>
        	<xsd:documentation>Some spells (Disrupt) can be aimed at certain kinds of Combat Tile Borders (Stone walls).</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="targetCombatTileBorderID" type="momimecommon:combatTileBorderID" use="required" nxe:label="Combat Tile Border ID" />
	</xsd:complexType>

	<xsd:complexType name="combatTileType" nxe:singular="Combat Tile Type" nxe:plural="Combat Tile Types" nxe:submenu="Combat Map">
        <xsd:annotation>
        	<xsd:documentation>Defines logical combat tiles, e.g. "a dark area", "a ridge", "a house".  The actual image used to display the combat tile then depends on the overland terrain type (e.g. grass or mountains)
and the smoothing rules defined in the graphics XML file, especially with regard to ridges and the borders of dark areas which are smoothed in the same way as the overland map.
If there are multiple possible images (e.g. houses) they all have the same logical tile type - the actual image is then chosen at random from the graphics XML file.
Note even combats on mountain terrain, the regular terrain still only costs 1 movement (so movement rates implied by the overland movement rate rules aren't applicable).

Zero value indicates the terrain in this layer has no effect on movement (e.g. houses).  Negative movement value indicates impassable.  Movement rates ignored for flying or non-corporeal units.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="doubleMovement" type="momimecommon:combatTileTypeDoubleMovement" nxe:label="2x Movement to enter this tile" nxe:gridwidth="200" />
		</xsd:sequence>
		<xsd:attribute name="combatTileTypeID" type="momimecommon:combatTileTypeID" use="required" nxe:label="Combat Tile Type ID" nxe:gridwidth="130" />
	</xsd:complexType>
	
	<xsd:complexType name="combatTileBorder" nxe:singular="Combat Tile Border" nxe:plural="Combat Tile Borders" nxe:submenu="Combat Map">
        <xsd:annotation>
        	<xsd:documentation>Defines possible borders to combat tiles, i.e. wall of stone/fire/darkness.  These are places on the border between two combat tiles rather than being a tile themselves.
To keep things simple, the graphics XML file has a quite simple mapping which combines the border type with the directions the border runs in to produce a list of possible images - there is no smoothing.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="blocksMovement" type="momimecommon:combatTileBorderBlocksMovementID" nxe:label="Blocks movement?" nxe:showmaincolumn="false" />
		</xsd:sequence>
		<xsd:attribute name="combatTileBorderID" type="momimecommon:combatTileBorderID" use="required" nxe:label="Combat Tile Border ID" nxe:gridwidth="150" />
	</xsd:complexType>

	<xsd:complexType name="movementRateRule" nxe:singular="Movement Rate Rule" nxe:plural="Movement Rate Rules" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Defines a list of rules for deciding the movement rate of units over different types of terrain.  Rules are evaluated in order, and the first one found that applies will dictate the units' movement over this type of terrain.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="tileTypeID" type="momimecommon:tileTypeID" nxe:label="Tile Type" nxe:gridwidth="80">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>tileTypeDescription</nxe:showreferencedfield>
						<nxe:showreferencedfield>isLand</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitSkillID" type="momimecommon:unitSkillID" nxe:label="Our skill" nxe:gridwidth="100">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitStackSkillID" type="momimecommon:unitSkillID" nxe:label="Stacked skill" nxe:gridwidth="100">
				<xsd:annotation>
					<xsd:appinfo>
						<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
					</xsd:appinfo>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="doubleMovement" type="momimecommon:doubleMovement" nxe:label="2x Movement to enter this terrain" nxe:gridwidth="200" />
			<xsd:element minOccurs="0" maxOccurs="1" name="description" type="momimecommon:description" nxe:label="Description" nxe:gridwidth="300" />
		</xsd:sequence>
	</xsd:complexType>

<!-- Hero items, new for 0.9.7 -->
	
	<xsd:complexType name="heroItemType" nxe:singular="Hero Item Type" nxe:plural="Hero Item Types" nxe:submenu="Hero items">
        <xsd:annotation>
        	<xsd:documentation>Types of hero items - sword, axe, ring, shield, plate mail, and so on.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="baseCraftingCost" type="momimecommon:spellCastingCost" nxe:label="Base Crafting Cost" nxe:gridwidth="100" />
			<xsd:element minOccurs="1" maxOccurs="1" name="itemBonusCraftingCostMultiplier" type="momimecommon:spellCastingCost" nxe:label="Cost Multiplier" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemTypeBasicStat" type="momimecommon:unitSkillAndValue" nxe:label="Basic Stat" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemTypeAttackType" type="momimecommon:heroItemTypeAttackType" nxe:label="Attack Type" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemTypeAllowedBonus" type="momimecommon:heroItemTypeAllowedBonus" nxe:label="Allowed Bonus" nxe:gridwidth="100" />
		</xsd:sequence>
		<xsd:attribute name="heroItemTypeID" type="momimecommon:heroItemTypeID" use="required" nxe:label="Item Type ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="heroItemTypeAttackType" nxe:singular="Attack Type" nxe:plural="Attack Types">
        <xsd:annotation>
        	<xsd:documentation>Specifies the kind of attacks appropriate for the type of item, e.g. swords only affect melee attacks, but axes also affect thrown attacks.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="unitSkillID" type="momimecommon:unitSkillID" use="required" nxe:label="Skill" nxe:gridwidth="200">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="heroItemSlotType" nxe:singular="Hero Item Slot Type" nxe:plural="Hero Item Slot Types" nxe:submenu="Hero items">
        <xsd:annotation>
        	<xsd:documentation>Defines the different "item slots" heroes can have for, e.g. some heroes can only use a sword, some can only use a wand, but some have a slot that can take either.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroSlotAllowedItemType" type="momimecommon:heroSlotAllowedItemType" nxe:label="Allowed item type" nxe:gridwidth="100" />
		</xsd:sequence>
		<xsd:attribute name="heroItemSlotTypeID" type="momimecommon:heroItemSlotTypeID" use="required" nxe:label="Slot Type ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="heroSlotAllowedItemType" nxe:singular="Allowed Item Type" nxe:plural="Allowed Item Types" nxe:submenu="Hero items">
        <xsd:annotation>
        	<xsd:documentation>Defines the different kinds of hero items that can be equipped in the different kinds of slots.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="heroItemTypeID" type="momimecommon:heroItemTypeID" use="required" nxe:label="Item Type ID" nxe:gridwidth="100">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>heroItemTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="heroItemBonus" nxe:singular="Hero Item Bonus" nxe:plural="Hero Item Bonuses">
        <xsd:annotation>
        	<xsd:documentation>Lists all possible stats and bonuses that can be added to hero items.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="bonusCraftingCost" type="momimecommon:spellCastingCost" nxe:label="Bonus Crafting Cost" nxe:gridwidth="150">
		        <xsd:annotation>
		        	<xsd:documentation>Mandatory for every bonus except "Spell Charges", where the cost is calculated depending on which spell is added.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="1" maxOccurs="1" name="craftingCostMultiplierApplies" type="xsd:boolean" nxe:label="Cost multiplier applies?" nxe:gridwidth="150" />
			<xsd:element minOccurs="0" maxOccurs="1" name="allowCombiningWithBonusesToSameStat" type="xsd:boolean" nxe:label="Allow combining with bonuses to same stat?" nxe:gridwidth="150">
		        <xsd:annotation>
		        	<xsd:documentation>This is for the "Flaming" hero item bonus.  Normally two bonuses cannot be chosen if they provide a bonus to the same stat, so you cannot
pick both e.g. +1 and +2 attack on the same item.  However "Flaming" looks identical to +3 attack, so we need some flag that indicates that its OK to have both Flaming and +attack together.</xsd:documentation>
		        </xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemBonusPrerequisite" type="momimecommon:pickAndQuantity" nxe:label="Prerequisites" nxe:gridwidth="100" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemBonusStat" type="momimecommon:heroItemBonusStat" nxe:label="Bonus Stat" nxe:gridwidth="100" />
		</xsd:sequence>
		<xsd:attribute name="heroItemBonusID" type="momimecommon:heroItemBonusID" use="required" nxe:label="Item Bonus ID" nxe:gridwidth="100" />
	</xsd:complexType>

	<xsd:complexType name="heroItemBonusStat" nxe:singular="Hero Item Bonus Stat" nxe:plural="Hero Item Bonus Stats">
        <xsd:annotation>
        	<xsd:documentation>Lists the skills that a particular hero item bonus grants.</xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
			<xsd:extension base="momimecommon:unitSkillAndValue">
				<xsd:sequence>
					<xsd:element minOccurs="0" maxOccurs="1" name="appliesOnlyToAttacksAppropriateForTypeOfHeroItem" type="xsd:boolean" nxe:label="Applies only to attacks appropriate for type of hero item?">
				        <xsd:annotation>
				        	<xsd:documentation>Attack bonuses such as "Lightning" only grant their effect when the hero is making an attack that's appropriate for the type of hero item the bonus is imbued in.
e.g. The Elven Archer hero can use both swords and bows, but if she has a Sword of Lightning then it doesn't make her ranged attacks armour piercing.</xsd:documentation>
				        </xsd:annotation>
					</xsd:element>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="heroItemTypeAllowedBonus" nxe:singular="Bonus" nxe:plural="Bonuses" nxe:submenu="Hero items">
        <xsd:annotation>
        	<xsd:documentation>Specifies the list of bonuses which are allowed for each item type, e.g. you can't add +attack onto a shield.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="heroItemBonusID" type="momimecommon:heroItemBonusID" use="required" nxe:label="Item Bonus ID" nxe:gridwidth="100">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>heroItemBonusDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

	<xsd:complexType name="heroItem" nxe:singular="Hero Item" nxe:plural="Hero Items" nxe:submenu="Hero items">
        <xsd:annotation>
        	<xsd:documentation>Defines one actual hero item, whether one of the standard 250 predefined items, or a custom one created via Create Artifact.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
		<xsd:element minOccurs="1" maxOccurs="1" name="heroItemName" type="momimecommon:description" nxe:label="Name" nxe:gridwidth="200" />
		<xsd:element minOccurs="1" maxOccurs="1" name="heroItemTypeID" type="momimecommon:heroItemTypeID" nxe:label="Item Type ID" nxe:gridwidth="100">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>heroItemTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:element>
		<xsd:element minOccurs="1" maxOccurs="1" name="heroItemImageNumber" type="momimecommon:imageNumber" nxe:label="Image Number" nxe:gridwidth="100" />
		<xsd:element minOccurs="0" maxOccurs="1" name="spellID" type="momimecommon:spellID" nxe:label="Spell Charges" nxe:gridwidth="100">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>spellName</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:element>
		<xsd:element minOccurs="0" maxOccurs="1" name="spellChargeCount" type="momimecommon:spellCount" nxe:label="Spell Charge Count" nxe:gridwidth="150" />
		<xsd:element minOccurs="0" maxOccurs="unbounded" name="heroItemChosenBonus" type="momimecommon:heroItemTypeAllowedBonus" nxe:label="Bonus" nxe:gridwidth="100" />
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="heroItemSlot" nxe:singular="Hero Item Slot" nxe:plural="Hero Item Slots">
        <xsd:annotation>
        	<xsd:documentation>Lists the 3 "item slots" a hero has, so that fighter-type heroes typically have a Sword slot, Shield slot and a special item (Ring) slot, whereas mage-type heroes typically have a Wand slot and two special item (Ring) slots.</xsd:documentation>
        </xsd:annotation>
		<xsd:attribute name="heroItemSlotTypeID" type="momimecommon:heroItemSlotTypeID" use="required" nxe:label="Item Type">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>slotTypeDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

<!-- Damage types and immunities, new for 0.9.7.2 -->

	<xsd:complexType name="damageType" nxe:singular="Damage Type" nxe:plural="Damage Types" nxe:submenu="Units">
        <xsd:annotation>
        	<xsd:documentation>Types of damage, e.g. fire, cold, death, disintegrate - these map closely to the different immunity skills.</xsd:documentation>
        </xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="enhancedVersion" type="momimecommon:damageTypeID" nxe:label="Enhanced Version" nxe:showreferencedcolumns="false" />
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="damageTypeImmunity" type="momimecommon:damageTypeImmunity" nxe:label="Immunity" nxe:gridwidth="100" />
		</xsd:sequence>
		<xsd:attribute name="damageTypeID" type="momimecommon:damageTypeID" use="required" nxe:label="Damage Type ID" nxe:gridwidth="120" />
	</xsd:complexType>

	<xsd:complexType name="damageTypeImmunity" nxe:singular="Immunity" nxe:plural="Immunities">
        <xsd:annotation>
        	<xsd:documentation>Specifies the immunity skills that provide protection against this type of damage, and what kind of protection they provide.</xsd:documentation>
        </xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="boostsDefenceTo" type="momimecommon:unitSkillValue" nxe:label="Defence Boost" nxe:gridwidth="100">
		        <xsd:annotation>
        			<xsd:documentation>Indicates the boost to the target's defence stat that having this kind of immunity will grant.  This is a "minimum of", not an addition.
e.g. Weapon Immunity boosts defence to a minimum of 10, so a unit which had defence of 4 gets a defence score of 10, not 14.
If this value is left null, the unit is completely immune to this type of damage and will not be allowed as a target for spells that deal this type of damage.

Implication is that for spells and attacks whose damage resolution is based on resistance rather than defence, that null is the only value that makes sense here.</xsd:documentation>
        		</xsd:annotation>
			</xsd:element>
        </xsd:sequence>
		<xsd:attribute name="unitSkillID" type="momimecommon:unitSkillID" use="required" nxe:label="Skill" nxe:gridwidth="200">
			<xsd:annotation>
				<xsd:appinfo>
					<nxe:showreferencedfield>unitSkillDescription</nxe:showreferencedfield>
				</xsd:appinfo>
			</xsd:annotation>
		</xsd:attribute>
	</xsd:complexType>

<!-- Generic simple data types that are not really MoM specific -->

	<xsd:simpleType name="description">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
<!-- PK identifiers for the new game database entities defined in this XSD -->

	<xsd:simpleType name="overlandMapSizeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="landProportionID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="nodeStrengthID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="difficultyLevelID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="fogOfWarSettingID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitSettingID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="spellSettingID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

<!-- PK identifiers for the client database entities defined in this XSD -->

	<xsd:simpleType name="planeNumber">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="tileTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="productionTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="mapFeatureID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="pickTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="pickID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="wizardID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="raceID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="taxRateID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="buildingID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="rangedAttackTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="weaponGradeNumber">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitSkillID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="combatAreaEffectID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="spellID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="combatTileTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="combatTileBorderID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="heroItemTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="heroItemSlotTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="heroItemBonusID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="damageTypeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

<!-- PK identifiers for entities defined in the server XSD -->

	<xsd:simpleType name="populationTaskID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="spellRankID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="citySpellEffectID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="citySizeID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="heroNameID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
<!-- Moved from new game database XSD -->
	
	<xsd:simpleType name="percentage">
		<xsd:restriction base="xsd:unsignedShort">
			<xsd:maxInclusive value="100"></xsd:maxInclusive>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="doubledProductionValue">
        <xsd:annotation>
        	<xsd:documentation>Stores an amount of production something generates, or upkeep that something consumes.  Most production values in the game are stored as doubled values.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="undoubledProductionValue">
        <xsd:annotation>
        	<xsd:documentation>Stores an amount of production something generates, or upkeep that something consumes.  Most upkeep values in the game are stored directly, not doubled.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:int" />
	</xsd:simpleType>

	<xsd:simpleType name="mapTileCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="featureChance">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="cityPopulation">
        <xsd:annotation>
        	<xsd:documentation>Represents how many people are in a city.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="cityPopulationDiv1000">
        <xsd:annotation>
        	<xsd:documentation>Represents how many population figures are in a city, i.e. population divided by 1000 rounded down.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="unitCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="monsterStrength">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="treasureValue">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="spellBookCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="castingReductionCap">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="lairCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="cityCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="numberOfNodesOnPlane">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="nodeAuraSqaures">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="pickCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="integerMapDistance">
        <xsd:annotation>
        	<xsd:documentation>The number of map tiles between two locations on the map, as an integer (rounded) number (often the actual number of map moves it will take to get somewhere).</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
<!-- Client database enums -->
	
	<xsd:simpleType name="roundingDirectionID" nxe:singular="Rounding Direction ID">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Round down</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ROUND_DOWN" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>Round up</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ROUND_UP" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Must be an exact multiple</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MUST_BE_EXACT_MULTIPLE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="enforceProductionID" nxe:singular="Enforce Production ID">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Per Turn amount cannot go below zero</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PER_TURN_AMOUNT_CANNOT_GO_BELOW_ZERO" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Stored amount cannot go below zero</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="STORED_AMOUNT_CANNOT_GO_BELOW_ZERO" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="combatTileBorderBlocksMovementID" nxe:singular="Combat Tile Border Blocks Movement">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>No</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NO" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Cannot cross specified borders</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CANNOT_CROSS_SPECIFIED_BORDERS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Whole tile impassable</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="WHOLE_TILE_IMPASSABLE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="combatAreaAffectsPlayersID" nxe:singular="CAE Affects Players">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Player who cast the spell</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CASTER_ONLY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="O"><xsd:annotation>
				<xsd:documentation>Combat opponent of player who cast the spell</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="COMBAT_OPPONENT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Both players in combat</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BOTH_PLAYERS_IN_COMBAT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>All players (even outside of combat)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ALL_EVEN_NOT_IN_COMBAT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="fogOfWarValue" nxe:singular="Fog of War Value">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Always see once seen</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ALWAYS_SEE_ONCE_SEEN" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Remember as last seen</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="REMEMBER_AS_LAST_SEEN" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Forget</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FORGET" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="switchResearch" nxe:singular="Switch Research">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Switch disallowed until finish current research</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DISALLOWED" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Switch allowed only if current research not started</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ONLY_IF_NOT_STARTED" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="L"><xsd:annotation>
				<xsd:documentation>Switch allowed but lose research put into current spell</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="LOSE_CURRENT_RESEARCH" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Switch freely</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FREE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="castingReductionCombination" nxe:singular="Casting Reduction Combination">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Additive</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ADDITIVE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Multiplicative</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MULTIPLICATIVE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
<!-- Needed both by the server XSD and message layer -->

	<xsd:simpleType name="combatMapLayerID" nxe:singular="Combat Map Layer">
        <xsd:annotation>
        	<xsd:documentation>Combat maps are split into 3 layers, in such a way that each map cell can then only contain one item in each layer (but may contain an item in all 3).  There are then special layers on top of this contains the borders/walls (4th) and the units (5th).
Lowest layer contains the terrain and ridges.  All terrain is passable, but some ridges cost double to move over (some buildings are impassable).
Middle layer contains the roads, both within the city (if applicable) and roads leading in/out of the map tile.  Roads (including enchanted roads) cost half to move over.
Buildings and terrain featues such as trees are in the top layer.  Some are passable (e.g. housing), some are not (e.g. wizards' fortress).
Movement rules start from the top layer and work down, i.e. check if there is an impassable building, if not then check if there is a road, if not then check if there is a ridge.
   i.e. if there is a road over a ridge, it still only costs half movement.  NB. This means the order these constants are defined in is vitally important.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Terrain layer</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="TERRAIN" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Road layer</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ROAD" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Building/terrain feature layer</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILDINGS_AND_TERRAIN_FEATURES" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="spellBookSectionID" nxe:singular="Spell Book Section">
        <xsd:annotation>
        	<xsd:documentation>Spell book sections not only define the way they're grouped in the spell book UI, but they also define the rules
about what a spell must be targetted on.  e.g. Unit enchantments must be targetted on a friendly unit, but unit curses must be targetted on an enemy unit.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="SC01"><xsd:annotation>
				<xsd:documentation>Summoning spells</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SUMMONING" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC02"><xsd:annotation>
				<xsd:documentation>Overland enchantments</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="OVERLAND_ENCHANTMENTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC03"><xsd:annotation>
				<xsd:documentation>City enchantments</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CITY_ENCHANTMENTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC04"><xsd:annotation>
				<xsd:documentation>Unit enchantments</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNIT_ENCHANTMENTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC05"><xsd:annotation>
				<xsd:documentation>Combat enchantments</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="COMBAT_ENCHANTMENTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC06"><xsd:annotation>
				<xsd:documentation>City curses</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CITY_CURSES" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC07"><xsd:annotation>
				<xsd:documentation>Unit curses</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNIT_CURSES" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC08"><xsd:annotation>
				<xsd:documentation>Attack spells</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTACK_SPELLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC09"><xsd:annotation>
				<xsd:documentation>Special spells targetted at our own units; if combatBaseDamage is set then its a healing spell, otherwise its a recall spell; spellValidUnitTarget entries apply</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SPECIAL_UNIT_SPELLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC10"><xsd:annotation>
				<xsd:documentation>Special spells targetted at a location on the overland map, can be any map tile, doesn't have to be targetted on a particular unit/city;
the exact type of spell is currently dictated by whether or not spellScoutingRange is filled in</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SPECIAL_OVERLAND_SPELLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC11"><xsd:annotation>
				<xsd:documentation>Special spells targetted at a location on the combat map, can be any combat tile, doesn't have to be targetted on a particular unit;
the exact type of spell is currently dictated by whether there any spellValidBorderTarget records or not</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SPECIAL_COMBAT_SPELLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC12"><xsd:annotation>
				<xsd:documentation>Dispelling spells</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DISPEL_SPELLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC98"><xsd:annotation>
				<xsd:documentation>Researchable now - One of the 8 options for what to research next</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESEARCHABLE_NOW" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="SC99"><xsd:annotation>
				<xsd:documentation>Researchable - Just not yet (e.g. you have to research most Common spells before proceeding to Uncommon, etc.)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESEARCHABLE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
<!-- Client database data types -->

	<xsd:simpleType name="pickQuantity">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>	
	
	<xsd:simpleType name="pickCost">
        <xsd:annotation>
        	<xsd:documentation>Stores how many start of game picks a particular type of magic book or retort takes to pick, e.g. Warlord costs 2 picks.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="prerequisiteCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="cityPopulationGrowthRate">
        <xsd:annotation>
        	<xsd:documentation>Represents how much a city population grows/dies each turn.  Also used to store modifiers to this, e.g. that a Granary adds +20 population per turn.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="mineralBonusMultiplier">
		<xsd:restriction base="xsd:unsignedShort">
			<xsd:minInclusive value="1"></xsd:minInclusive>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="unrestLiteral">
        <xsd:annotation>
        	<xsd:documentation>Most unrest is calculated based on percentages.  This is used for the rare situations where unrest is adjusted in terms of a definite number of (1000s of) population.
This is used to model the special -2 adjustment that Klackons get.  This is a literal value, so a calming effect of 2 is stored as -2 (unrest is modified by -2).</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="buildingUnrestReduction">
        <xsd:annotation>
        	<xsd:documentation>Number of (1000s of) people who are calmed by the presence of a particular type of building.
This is a reduction value - so an Oracle with a calming effect of 2 is stored as +2 (a reduction of 2).</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="experiencePoints">
        <xsd:annotation>
        	<xsd:documentation>Stores the number of experience points a particular unit has, gains, or needs.  So for a regular this is 20 (as opposed to the experience *level* for regulars which is 1).</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="experienceLevelNumber">
        <xsd:annotation>
        	<xsd:documentation>Stores the experience level a particular unit has attained or needs.  So for a regular this is 1 (as opposed to the experience *points* for regulars which is 20).</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="productionCost">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="imageNumber">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitSkillValue">
        <xsd:annotation>
        	<xsd:documentation>MoM IME by convention uses positive skill values for ALL skills (in the original MoM it was dubious whether saving throw penalty skills like Death Gaze -2 or Death Gaze -4 were stored as -2 or +2).
However we still need to record negative skill modification values, e.g. True Light makes skills of death creatures less effective, and Darkness makes skills of life creatures less effective.</xsd:documentation>
        </xsd:annotation>
        <xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="skillDivisor">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="scoutingRange">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="colour">
        <xsd:annotation>
        	<xsd:documentation>Colour value, stored as 6 hex characters RRGGBB.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:length value="6" />
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="experienceLevelRingCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="figureCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="doubleMovement">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="spellCastingCost">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="spellResearchCost">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="savingThrowModifier">
        <xsd:annotation>
        	<xsd:documentation>Stores how much a unit's resistance saving throw is modified by a particular spell.  This is a literal value, so e.g. Black Sleep is harder to resist, so has a saving throw modifier of -2.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="combatTileTypeDoubleMovement">
		<xsd:restriction base="xsd:int" />
	</xsd:simpleType>
	
	<xsd:simpleType name="unitCombatSideID">
	    <xsd:annotation>
    		<xsd:documentation>Keeps track of which side of combat a unit is on; null if they aren't involved in a combat at the moment.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Defender</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DEFENDER" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Attacker</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTACKER" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="transportCapacity">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
<!-- Attack spells and proper attack resolution, new for 0.9.6 -->
	
	<xsd:simpleType name="attackSpellCombatTargetID">
	    <xsd:annotation>
			<xsd:documentation>For attack spells that can be used in combat, specifies whether the spell hits a
single unit (e.g. fire bolt, fireball, doom bolt) or all units (e.g. flame strike)</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Caster chooses single enemy unit to aim spell at</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SINGLE_UNIT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Spell automatically hits all enemy units in combat (e.g. flame strike)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ALL_UNITS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="storedDamageTypeID">
		<xsd:annotation>
			<xsd:documentation>Damage is stored against units under the following categories.
Note the order of these is important - damage will always be healed in the order listed here - so we heal healable damage first, then
life stealing damage, then permanent damage.  Permanent damage can't be healed by healing spells, only by the regular 1 HP healing per turn on the overland map,
which is why it is last in the list, so it will only be healed when all healable and life stealing damage is taken care of.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="H"><xsd:annotation>
				<xsd:documentation>Healable damage (normal damage that will heal itself over time, or can be healed with spells)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="HEALABLE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="L"><xsd:annotation>
				<xsd:documentation>Life stealing damage (damage from ghouls and life drain; if more than half of damage dealt is life stealing, the unit will become undead)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="LIFE_STEALING" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Permanent damage (damage from stoning, banishing, disintegration and such that cannot be healed)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PERMANENT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="damageResolutionTypeID">
		<xsd:annotation>
			<xsd:documentation>Different rules for resolving damage that can be dealt by different skills, attacks and attack spells.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Single figure (normal attack where first figure defends and takes hits, then second figure defends and takes hits, and so on)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SINGLE_FIGURE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Armour piercing (same as S, but target's defence is halved)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ARMOUR_PIERCING" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="I"><xsd:annotation>
				<xsd:documentation>Illusionary (same as S, but target's defence is zeroed)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ILLUSIONARY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Multi figure (immolation attack where all figures are hit, regardless of how many actually die)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MULTI_FIGURE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Resist or take damage equal to the amount the resistance roll was missed by (life drain/steal)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESIST_OR_TAKE_DAMAGE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Make n resistance rolls, losing 1 HP for each failed roll (poison touch)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESISTANCE_ROLLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Each figure must resist or die (petrify, stoning gaze)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="EACH_FIGURE_RESIST_OR_DIE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Single figure must resist or die (stoning touch)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SINGLE_FIGURE_RESIST_OR_DIE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Doom (constant damage)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DOOM" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Disintegrate if resistance 9 or less</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DISINTEGRATE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Fixed % chance of whole unit dying completely (cracks call)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CHANCE_OF_DEATH" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Z"><xsd:annotation>
				<xsd:documentation>Zeroes ammo remaining (warp wood)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ZEROES_AMMO" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Y"><xsd:annotation>
				<xsd:documentation>Each figure must resist or can make no further attacks during this attack resolution (fear)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FEAR" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>


	<xsd:simpleType name="negatedByUnitID">
        <xsd:annotation>
        	<xsd:documentation>Some skills are negated by enemy skills (e.g. Negate First Strike); others are negated by our own skills (e.g. Resist Elements).</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="O"><xsd:annotation>
				<xsd:documentation>Negated by a skill on our unit</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="OUR_UNIT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="E"><xsd:annotation>
				<xsd:documentation>Negated by a skill on the enemy unit</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ENEMY_UNIT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
<!-- Datatypes not needed directly here, but used both in server and other XSDs -->
	
	<xsd:simpleType name="spellCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="directions">
	    <xsd:annotation>
    		<xsd:documentation>List of directions from 0..8 in length, of numbers 1..8.  Ideally should change this to a 0..unbounded of type map:mapDirection.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="languageCategoryID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="languageEntryID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="ipAddress">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>
	
	<xsd:simpleType name="knownServerID">
		<xsd:restriction base="xsd:normalizedString" />
	</xsd:simpleType>

	<xsd:simpleType name="pickTypeCount">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="unitSkillComponent">
	    <xsd:annotation>
			<xsd:documentation>Different things that can contribute to a unit's skill values; defined so we can colour them separately on the Unit Info screen.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Total of all the below (this is all the server ever uses)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ALL" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Basic value defined in the server XML</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BASIC" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="W"><xsd:annotation>
				<xsd:documentation>Bonus from normal unit having magical, mithril or adamantium weapons</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="WEAPON_GRADE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="E"><xsd:annotation>
				<xsd:documentation>Bonus from normal unit or hero being experienced</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="EXPERIENCE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="H"><xsd:annotation>
				<xsd:documentation>Bonus from the types of hero skills that simply add to an attribute, e.g. Might +5 simply adds +5 to melee attack strength</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="HERO_SKILLS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="I"><xsd:annotation>
				<xsd:documentation>Bonus from equipped hero items</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="HERO_ITEMS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Bonus from other skills or spell effects, e.g. Holy Armour adding +2 to defence</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SPELL_EFFECTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Bonus from other skills or spell effects that affect the whole unit stack, e.g. Resistance to All or Holy Bonus</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SPELL_EFFECTS_STACK" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Bonus from combat area effects, including CAE-type spells, e.g. node auras or prayer</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="COMBAT_AREA_EFFECTS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="unitSkillPositiveNegative">
	    <xsd:annotation>
			<xsd:documentation>This is used on the unit info screen to show when stats have been reduced, e.g. by Black Prayer, Vertigo, Warp Reality.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Positive</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="POSITIVE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Negative</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NEGATIVE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Both</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BOTH" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="unitSpecialOrder">
	    <xsd:annotation>
    		<xsd:documentation>Different special orders that units can be given.
All of these except for msoPatrol are only used in simultaneous turn games - in one-player-at-a-time games, these kinds of commands are executed instantly.
Units with special orders won't be asked for movement orders and look visibly different on the map.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Patrol</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PATROL" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Build city</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_CITY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Build road</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_ROAD" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Meld with node</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MELD_WITH_NODE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>Purify</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PURIFY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Dismiss</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DISMISS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
<!-- Enums cannot be extended, so I avoid defining any in the server/client XSDs to avoid changing dozens of import statements between MoM IME versions -->	

	<xsd:simpleType name="aiBuildingTypeID">
        <xsd:annotation>
        	<xsd:documentation>Building types that the AI uses to decide which order to construct buildings in raider and AI wizards' cities.'</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="G"><xsd:annotation>
				<xsd:documentation>Growth</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="GROWTH" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Production</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PRODUCTION" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Unrest / Magic Power</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNREST_AND_MAGIC_POWER" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Research</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESEARCH" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>Units</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNITS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Z"><xsd:annotation>
				<xsd:documentation>Gold</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="GOLD" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>Unrest without Magic Power</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNREST_WITHOUT_MAGIC_POWER" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="aiMovementCode">
		<xsd:annotation>
			<xsd:documentation>Condition checks and rules the AI can use to decide where to move overland.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>If there are any reachable undefended (our/their empty cities, empty nodes/lairs/towers) or underdefended locations (our cities/nodes/towers), then head there.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="REINFORCE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>If there are any reachable defended locations (their cities/nodes/lairs/towers) where the sum of our UARs > the sum of their UARs, then head there/attack them.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTACK_STATIONARY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="W"><xsd:annotation>
				<xsd:documentation>If there are any reachable enemy unit stacks where the sum of our UARs > the sum of their UARs, then head there/attack them.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTACK_WANDERING" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>If there is any reachable unscouted terrain with an adjacent land tile then head there.
(This doesn't imply the units can walk on land - boats use this to trace coastlines).</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SCOUT_LAND" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Z"><xsd:annotation>
				<xsd:documentation>If there is any reachable unscouted terrain then head there.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SCOUT_ALL" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="J"><xsd:annotation>
				<xsd:documentation>If there are any reachable defended locations (their cities/nodes/lairs/towers) where the sum of their UARs >= the sum of our UARs,
and any other reachable stacks of our units of the same category, then head to join the unit stacks together.  (This needs some care so that in simultaneous turns games,
the two unit stacks don't keep crossing past each other).</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="JOIN_STACK" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>If there is a reachable Tower that is garrisoned by our units, and if we imagine we are standing at the tower and recheck all
preceeding movement codes then we would have something useful to do on the other plane, then head to the tower.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PLANE_SHIFT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="T"><xsd:annotation>
				<xsd:documentation>If we are in a transport then stay there.  If we aren't in a transport but can reach one that has space remaining, then head for it.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="GET_IN_TRANSPORT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>If we can reach any of our defended locations (cities/nodes/towers) then head there.
Also, this flags up an alert that there are units on this island/continent that have nothing to do, so red flags the entire continent as "transport needed here".</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="OVERDEFEND" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>If we can reach a good spot to build a city then head there and do so.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_CITY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="E"><xsd:annotation>
				<xsd:documentation>If we can see any two of our cities on the same land mass unconnected by road, then trace a path between them a build road there.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_ROAD" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="O"><xsd:annotation>
				<xsd:documentation>If we can reach any corrupted terrain that's in the resource radius for one of our cities then head there and purify it.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PURIFY" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>If we can reach any node not captured by us that has no enemy defending it then head there and try to meld with it.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MELD_WITH_NODE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>If we are currently carrying any unit stack(s) then check all islands/continents we could take them to.  Imagine we unloaded the units there,
then use the movement codes of the unit stack(s) being carried to see if they would have something useful to do on that island/continent.  If so, then take them there.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CARRY_UNITS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="L"><xsd:annotation>
				<xsd:documentation>If we are currently empty, and can reach any island/continent that was red flagged by the OVERDEFEND (D) code, then head there.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="LOAD_UNITS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>If we are on the same plane as our Wizard's Fortress, then head to the island/continent that it is on.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FORTRESS_ISLAND" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>	

	<xsd:simpleType name="rangedAttackTypeActionID">
        <xsd:annotation>
        	<xsd:documentation>Types of action we can define an image for a ranged attack type for.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="FLY">
				<xsd:annotation><xsd:documentation>Image of the rock/fireball/etc flying towards its target</xsd:documentation></xsd:annotation>
			</xsd:enumeration>
			<xsd:enumeration value="STRIKE">
				<xsd:annotation><xsd:documentation>Image of the rock/fireball/etc striking its target</xsd:documentation></xsd:annotation>
			</xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="frontOrBack">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Front</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FRONT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="B"><xsd:annotation>
				<xsd:documentation>Back</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BACK" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="unitCombatScale">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Double size units</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DOUBLE_SIZE_UNITS" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Four times figures</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FOUR_TIMES_FIGURES" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Four times figures except for single-figure summoned creatures</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FOUR_TIMES_FIGURES_EXCEPT_SINGLE_SUMMONED" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="damagePerFigureID">
        <xsd:annotation>
        	<xsd:documentation>Defines whether damage is dealt from a unit as a whole or individual figures.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>The unit deals the damage as a whole, no matter how many it figures it has alive or has lost</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PER_UNIT" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>The damage is multiplied by the number of alive figures and dealt as a single combined attack</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PER_FIGURE_COMBINED" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Each alive figure makes a separate attack that can be defended against separately</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PER_FIGURE_SEPARATE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="unitSkillTypeID">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Unit attributes such as Melee attack Strength, Resistance and Hit Points.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTRIBUTE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Skills alterable by modifiers such as node auras, prayer, weapon grade bonuses, or experience, e.g. Thrown Weapons or Breath attacks.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MODIFYABLE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="F"><xsd:annotation>
				<xsd:documentation>Skills that have a fixed unmodifyable value, e.g. Poison Attack or Immolation.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="FIXED" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Skills that have no value, e.g. Create Outpost or Invisibility.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NO_VALUE" /></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="shortcut">
        <xsd:annotation>
        	<xsd:documentation>Defines the shortcut keys supported by this version.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<!-- Overland map shortcut keys -->
			<xsd:enumeration value="ARMIES_SCREEN" />
			<xsd:enumeration value="CENTRE_OVERLAND_ON_SELECTED_UNIT" />
			<xsd:enumeration value="GAME_SCREEN" />
			<xsd:enumeration value="MAGIC_SCREEN" />
			<xsd:enumeration value="NEXT_TURN" />
			<xsd:enumeration value="SWITCH_PLANE" />
			<xsd:enumeration value="SPELLBOOK" />
			<xsd:enumeration value="ZOOM_IN" />
			<xsd:enumeration value="ZOOM_OUT" />

			<!-- The latter part of these names must exactly match the enums defined in SquareMapDirection.java -->
			<xsd:enumeration value="MOVE_OVERLAND_NORTH" />
			<xsd:enumeration value="MOVE_OVERLAND_NORTHEAST" />
			<xsd:enumeration value="MOVE_OVERLAND_EAST" />
			<xsd:enumeration value="MOVE_OVERLAND_SOUTHEAST" />
			<xsd:enumeration value="MOVE_OVERLAND_SOUTH" />
			<xsd:enumeration value="MOVE_OVERLAND_SOUTHWEST" />
			<xsd:enumeration value="MOVE_OVERLAND_WEST" />
			<xsd:enumeration value="MOVE_OVERLAND_NORTHWEST" />
			
			<xsd:enumeration value="OVERLAND_MOVE_DONE" />
			<xsd:enumeration value="OVERLAND_MOVE_WAIT" />
			<xsd:enumeration value="BUILD_ROAD_OR_CITY" />
			
			<xsd:enumeration value="ADVISOR_SCREEN" />
			<xsd:enumeration value="ADVISOR_SURVEYOR" />
			<xsd:enumeration value="ADVISOR_PARCHMENT_MAP" />
			<xsd:enumeration value="ADVISOR_SPELL_QUEUE" />
			<xsd:enumeration value="ADVISOR_POWER_GRAPH" />
			<xsd:enumeration value="ADVISOR_WIZARD_STATS" />
			<xsd:enumeration value="ADVISOR_MESSAGES" />
			<xsd:enumeration value="ADVISOR_TAX_RATE" />
			<xsd:enumeration value="ADVISOR_AUTO_CONTROL" />
			<xsd:enumeration value="ADVISOR_WIZARDS" />
			
			<!-- Combat map shortcut keys -->
			<xsd:enumeration value="COMBAT_TOGGLE_AUTO" />
			<xsd:enumeration value="COMBAT_TOGGLE_DAMAGE_CALCULATIONS" />
			<xsd:enumeration value="COMBAT_MOVE_DONE" />
			<xsd:enumeration value="COMBAT_FLEE" />
			<xsd:enumeration value="COMBAT_CAST_SPELL" />
			<xsd:enumeration value="COMBAT_MOVE_WAIT" />
			
			<!-- Other screen shortcut keys -->
			<xsd:enumeration value="ALCHEMY" />
			<xsd:enumeration value="HERO_ITEMS" />
			
			<!-- Generic message box shortcut keys -->
			<xsd:enumeration value="MESSAGE_BOX_CLOSE" />
			<xsd:enumeration value="MESSAGE_BOX_YES" />
			<xsd:enumeration value="MESSAGE_BOX_NO" />
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="virtualKey">
        <xsd:annotation>
        	<xsd:documentation>Defines virtual keys (untypeable special key values) supported by this version.</xsd:documentation>
        </xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="VK_F1" />
			<xsd:enumeration value="VK_F2" />
			<xsd:enumeration value="VK_F3" />
			<xsd:enumeration value="VK_F4" />
			<xsd:enumeration value="VK_F5" />
			<xsd:enumeration value="VK_F6" />
			<xsd:enumeration value="VK_F7" />
			<xsd:enumeration value="VK_F8" />
			<xsd:enumeration value="VK_F9" />

			<xsd:enumeration value="VK_LEFT" />
			<xsd:enumeration value="VK_RIGHT" />
			<xsd:enumeration value="VK_UP" />
			<xsd:enumeration value="VK_DOWN" />
			<xsd:enumeration value="VK_HOME" />
			<xsd:enumeration value="VK_END" />
			<xsd:enumeration value="VK_PAGE_UP" />
			<xsd:enumeration value="VK_PAGE_DOWN" />

			<xsd:enumeration value="VK_ADD" />
			<xsd:enumeration value="VK_SUBTRACT" />

			<xsd:enumeration value="VK_ENTER" />
		</xsd:restriction>
	</xsd:simpleType>
	
</xsd:schema>