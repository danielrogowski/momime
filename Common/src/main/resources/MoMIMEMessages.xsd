<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
	xmlns:mp="http://www.ndg.com/multiplayer/base" xmlns:mps="http://www.ndg.com/multiplayer/sessionbase" xmlns:map="http://www.ndg.com/map"
	xmlns:momimenewgame="http://momime/common/database/newgame/v0_9_4" xmlns:momimecommon="http://momime/common/database/v0_9_4"
	xmlns:momimeclient="http://momime/client/database/v0_9_4"
	xmlns:momimemsgs="http://momime/common/messages/v0_9_4" targetNamespace="http://momime/common/messages/v0_9_4"
	jaxb:version="2.0">

	<xsd:import namespace="http://www.ndg.com/map" schemaLocation="../../../../NdgMap/src/main/resources/Map.xsd" />
	<xsd:import namespace="http://www.ndg.com/multiplayer/base" schemaLocation="../../../../NdgMultiplayerBase/src/main/resources/Multiplayer.xsd"/>
	<xsd:import namespace="http://www.ndg.com/multiplayer/sessionbase" schemaLocation="../../../../NdgMultiplayerSessionBase/src/main/resources/MultiplayerSession.xsd"/>
	<xsd:import namespace="http://momime/common/database/newgame/v0_9_4" schemaLocation="MoMIMENewGameDatabase.xsd" />
	<xsd:import namespace="http://momime/common/database/v0_9_4" schemaLocation="MoMIMECommonDatabase.xsd" />
	<xsd:import namespace="http://momime/client/database/v0_9_4" schemaLocation="MoMIMEClientDatabase.xsd" />
    
    <xsd:annotation>
    	<xsd:documentation>Defines the portions of the messaging layer that are needed both by client-to-server and server-to-client messages.
This includes the session description and all knowledge structures - i.e. any runtime data structures, since these aren't data types defined in the server XSD.'</xsd:documentation>
	</xsd:annotation>

<!-- Descriptions -->
    
	<xsd:complexType name="momSessionDescription">
		<xsd:complexContent>
			<xsd:extension base="mps:sessionDescription">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="xmlDatabaseName" type="xsd:normalizedString"/>		<!-- should be of type filename, but no import on client XSD yet.. expect needed later -->
					<xsd:element minOccurs="1" maxOccurs="1" name="aiPlayerCount" type="xsd:unsignedShort"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="turnSystem" type="momimemsgs:turnSystem"/>
					
					<xsd:element minOccurs="1" maxOccurs="1" name="mapSize" type="momimenewgame:mapSizeData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="landProportion" type="momimenewgame:landProportionData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="nodeStrength" type="momimenewgame:nodeStrengthData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="difficultyLevel" type="momimenewgame:difficultyLevelData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="fogOfWarSetting" type="momimenewgame:fogOfWarSettingData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="unitSetting" type="momimenewgame:unitSettingData"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="spellSetting" type="momimenewgame:spellSettingData"/>
					
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="difficultyLevelNodeStrength" type="momimenewgame:difficultyLevelNodeStrengthData"/>
					
					<!--  Special debug options -->

					<xsd:element minOccurs="0" maxOccurs="1" name="disableFogOfWar" type="xsd:boolean"/>					
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
<!-- Runtime knowledge structures -->

	<xsd:complexType name="momResourceValue">
	    <xsd:annotation>
    		<xsd:documentation>Holds details about how much of one type of production a player has now + is generating each turn</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="productionTypeID" type="momimecommon:productionTypeID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="amountStored" type="momimenewgame:undoubledProductionValue"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="amountPerTurn" type="momimenewgame:undoubledProductionValue">
			    <xsd:annotation>
    				<xsd:documentation>This includes production from buildings, population, map features, consumption and maintenance spent on buildings and units.
It doesn't include where one type of production is converted into another, such as selling 2 rations for 1 gold,
or distributing magic power into mana, research and skill improvement.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="fogOfWarMemory">
	    <xsd:annotation>
    		<xsd:documentation>Structure which holds all the details a player remembers about the map and other items, or the true values on the server</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="map" type="momimemsgs:mapVolumeOfMemoryGridCells"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unit" type="momimemsgs:memoryUnit"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="building" type="momimemsgs:memoryBuilding"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="combatAreaEffect" type="momimemsgs:memoryCombatAreaEffect"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="maintainedSpell" type="momimemsgs:memoryMaintainedSpell"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="spellResearchStatus">
	    <xsd:annotation>
    		<xsd:documentation>Records the research status of one spell in a player's spell book</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="spellID" type="momimecommon:spellID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="remainingResearchCost" type="momimecommon:spellResearchCost"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="status" type="momimemsgs:spellResearchStatusID"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="momPersistentPlayerPrivateKnowledge">
	    <xsd:annotation>
    		<xsd:documentation>Holds all private knowledge that a player only knows about themselves, they can't see the values for other players,
    										and that is persisted into save game files.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="mps:persistentPlayerPrivateKnowledge">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="taxRateID" type="momimecommon:taxRateID"/>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="resourceValue" type="momimemsgs:momResourceValue"/>

					<xsd:element minOccurs="0" maxOccurs="1" name="spellIDBeingResearched" type="momimecommon:spellID"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="magicPowerDistribution" type="momimemsgs:magicPowerDistribution"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="manaSpentOnCastingCurrentSpell" type="momimecommon:spellCastingCost"/>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="spellResearchStatus" type="momimemsgs:spellResearchStatus"/>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="queuedSpellID" type="momimecommon:spellID"/>

					<xsd:element minOccurs="1" maxOccurs="1" name="nodeLairTowerKnownUnitIDs" type="momimemsgs:mapVolumeOfStrings">
				 	   <xsd:annotation>
    						<xsd:documentation>Lists unit IDs of nodes/lairs/towers that we've scouted; null = not yet scouted; empty string = scouted and it is empty</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="1" maxOccurs="1" name="fogOfWar" type="momimemsgs:mapVolumeOfFogOfWarStates"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="fogOfWarMemory" type="momimemsgs:fogOfWarMemory"/>
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="momTransientPlayerPrivateKnowledge">
	    <xsd:annotation>
    		<xsd:documentation>Holds all private knowledge that a player only knows about themselves, they can't see the values for other players,
    										but that is not persisted into save game files.  i.e. this is typically info we use during one turn and then discard.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="mps:transientPlayerPrivateKnowledge">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="overlandCastingSkillRemainingThisTurn" type="momimecommon:spellCastingCost"/>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="scheduledCombat" type="momimemsgs:momScheduledCombat"/>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="pendingMovement" type="momimemsgs:pendingMovement"/>

					<!-- These are only needed on the server during game startup - maybe worth creating a server side-only player knowledge structure in future -->
		        	<xsd:element minOccurs="0" maxOccurs="1" name="firstCityRaceID" type="momimecommon:raceID"/>
		        	<xsd:element minOccurs="0" maxOccurs="1" name="customPicksChosen" type="xsd:boolean"/>
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="playerPick">
	    <xsd:annotation>
    		<xsd:documentation>One pick (spell book or retort) and how many of them the player has.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="pickID" type="momimecommon:pickID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="originalQuantity" type="momimecommon:pickQuantity"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="quantity" type="momimecommon:pickQuantity"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="momPersistentPlayerPublicKnowledge">
	    <xsd:annotation>
    		<xsd:documentation>Holds all knowledge about a player in the game that is freely known to all players once they have joined the game,
    										and is persisted to save game files.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="mps:persistentPlayerPublicKnowledge">
		        <xsd:sequence>
					<xsd:element minOccurs="0" maxOccurs="1" name="wizardID" type="momimecommon:wizardID">
					    <xsd:annotation>
    						<xsd:documentation>RAIDERS and MONSTERS are special values; other values indicate pre-defined wizards;
    														null indicates a player who hasn't chosen a wizard yet; empty string represents a custom wizard</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="0" maxOccurs="1" name="standardPhotoID" type="momimecommon:wizardID">
					    <xsd:annotation>
    						<xsd:documentation>For pre-defined wizards or custom wizards choosing a standard photo, indicates the wizard ID of the photo;
    														for RAIDERS, MONSTERS and custom wizards uploading a custom photo, will be null</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="0" maxOccurs="1" name="customPhoto" type="xsd:base64Binary">
					    <xsd:annotation>
    						<xsd:documentation>Currently encoded in .ndgbmp format, likely will change this once client is also in Java</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="0" maxOccurs="1" name="customFlagColour" type="momimecommon:colour">
					    <xsd:annotation>
    						<xsd:documentation>Only filled in if player chose a custom photo, otherwise their flag colour is derived from standardPhotoID; whichever of the two is
    														used, the resulting value is written into momTransientPlayerPublicKnowledge so that we don't keep having to look up the flag colour of
    														standardPhotoIDs over and over again</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="0" maxOccurs="unbounded" name="pick" type="momimemsgs:playerPick"/>
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="momTransientPlayerPublicKnowledge">
	    <xsd:annotation>
    		<xsd:documentation>Holds all knowledge about a player in the game that is freely known to all players once they have joined the game,
    										but is not persisted to save game files.  i.e. this is typically info about what we know about what a player is doing during one turn.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="mps:transientPlayerPublicKnowledge">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="movementAllocatedForTurnNumber" type="momimemsgs:turnNumber"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="currentlyPlayingCombat" type="xsd:boolean"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="scheduledCombatUrnRequested" type="momimemsgs:scheduledCombatURN"/>
					
					<xsd:element minOccurs="0" maxOccurs="1" name="flagColour" type="momimecommon:colour">
					    <xsd:annotation>
    						<xsd:documentation>This is transient because it is only used client-side, and can be re-derived from either the customFlagColour or standardPhotoID.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>					
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="momGeneralPublicKnowledge">
	    <xsd:annotation>
    		<xsd:documentation>Holds all non-player specific knowledge that is commonly known to all players once they have joined the game.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="mps:generalPublicKnowledge">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="clientDatabase" type="momimeclient:clientDatabase"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="turnNumber" type="momimemsgs:turnNumber"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="currentPlayerID" type="mps:playerID">
					    <xsd:annotation>
    						<xsd:documentation>Optional because it will be null in simultaneous turns games.</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
		        </xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

<!-- Complex types -->

	<xsd:complexType name="magicPowerDistribution">
	    <xsd:annotation>
    		<xsd:documentation>Proportions of magic power that is being diverted into mana, research and skill improvement.
Values must add up to a total of 240.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="manaRatio" type="momimemsgs:magicPowerDistributionRatio"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="researchRatio" type="momimemsgs:magicPowerDistributionRatio"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="skillRatio" type="momimemsgs:magicPowerDistributionRatio"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="overlandMapCoordinates">
		<xsd:complexContent>
			<xsd:extension base="map:mapCoordinates">
		        <xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="plane" type="map:mapDimension"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
	<xsd:complexType name="combatMapCoordinates">
		<xsd:complexContent>
			<xsd:extension base="map:mapCoordinates"/>
        </xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="overlandMapTerrainData">
	    <xsd:annotation>
    		<xsd:documentation>Stores terrain values we remember about a map grid cell after it becomes obscured by Fog of War.
RiverDirections stores the list of directions in which a river runs from this tile, e.g. a tile with a river heading
off the tile downwards = 5; so RiverDirections is blank for tiles without a river.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="tileTypeID" type="momimenewgame:tileTypeID"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="mapFeatureID" type="momimecommon:mapFeatureID"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="riverDirections" type="momimecommon:directions"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="nodeOwnerID" type="mps:playerID">
	    		<xsd:annotation>
    				<xsd:documentation>This *does* resolve out across the full area of the aura, so will be set for all squares covered by the aura, not just the actual node tile.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="overlandMapCityData">
	    <xsd:annotation>
    		<xsd:documentation>Stores what we remember about a city after it becomes obscured by Fog of War.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="cityPopulation" type="momimenewgame:cityPopulationDiv1000"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="numberOfRebels" type="momimenewgame:cityPopulationDiv1000"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="minimumFarmers" type="momimenewgame:cityPopulationDiv1000"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="optionalFarmers" type="momimenewgame:cityPopulationDiv1000"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="cityRaceID" type="momimecommon:raceID"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="citySizeID" type="momimecommon:citySizeID"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="cityName" type="momimecommon:description"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="currentlyConstructingBuildingOrUnitID" type="momimecommon:unitID"/>		<!-- In future should split this into an xsd:choice -->
			<xsd:element minOccurs="0" maxOccurs="1" name="cityOwnerID" type="mps:playerID"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="memoryGridCell">
	    <xsd:annotation>
    		<xsd:documentation>Stores the things we remember about a map grid cell after it becomes obscured by Fog of War.
This is the only copy of the map the client has, it never receives a 'true' copy of the map.
The server has (players + 1) copies of this.  One to store what each player can see, and one 'true' copy of the map.

Note old Delphi version had a seperate permanentGridCell structure for productionSoFar and buildingIdSoldThisTurn, since these values
are only ever known for our own cities.  That really only makes a difference on the server, because the client only has one FOW memory anyway.
So the server just duplicates these values into the city owner's memory only.  So simplifies things by only having one map cell structure.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="0" maxOccurs="1" name="terrainData" type="momimemsgs:overlandMapTerrainData"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="cityData" type="momimemsgs:overlandMapCityData"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="productionSoFar" type="momimecommon:productionCost"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="buildingIdSoldThisTurn" type="momimecommon:buildingID"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="memoryBuilding">
	    <xsd:annotation>
    		<xsd:documentation>Stores a building that we remember after it becomes obscured by Fog of War.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="buildingID" type="momimecommon:buildingID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="cityLocation" type="momimemsgs:overlandMapCoordinates"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="memoryCombatAreaEffect">
	    <xsd:annotation>
    		<xsd:documentation>One area effect in place at a particular map location.
For example, node auras giving +2 stats to creatures of their realm, prayer, heavenly light, counter magic.

This isn't stored under the combat map, because we want to be able to set up area effects where the combat hasn't
happened yet, e.g. so if we scout a node and look at the stats of the creatures inside without actually attacking them they correctly show all their +2 stats.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="combatAreaEffectID" type="momimecommon:combatAreaEffectID"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="mapLocation" type="momimemsgs:overlandMapCoordinates">
			    <xsd:annotation>
    				<xsd:documentation>Optional - omitted if the effect applies to the entire map (e.g. eternal night) and therefore cannot be dispelled in combat.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="castingPlayerID" type="mps:playerID">
			    <xsd:annotation>
    				<xsd:documentation>Optional - omitted for natural map effects that are not the result of spells, such as node auras.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="memoryMaintainedSpell">
	    <xsd:annotation>
    		<xsd:documentation>Spell that has been cast and is ongoing (typically meaning it requires some amount of mana in maintenance cost).

Caution re: the difference between SpellID, UnitSkillID and CitySpellEffectID - SpellID specifies the original spell ID that was cast,
but some spells have multiple effects with their own codes - and its these codes that make the spell effect work, not the original SpellID.

e.g. Lionheart is SP141, but the unit skill it grants is SS141 Dark Rituals is SP163 but its effect is SE163

The two spells this is mainly for are:
     
Chaos Channels is SP093, but it will grant one of SS093A..C (at random)
Spell Ward is SP072, but it provides one of the effects SE072C,D,L,N,S (player's choice)</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="castingPlayerID" type="mps:playerID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="spellID" type="momimecommon:spellID"/>
			
			<xsd:element minOccurs="0" maxOccurs="1" name="unitURN" type="momimemsgs:unitURN"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="unitSkillID" type="momimecommon:unitSkillID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="castInCombat" type="xsd:boolean"/>
			
			<xsd:element minOccurs="0" maxOccurs="1" name="cityLocation" type="momimemsgs:overlandMapCoordinates"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="citySpellEffectID" type="momimecommon:citySpellEffectID"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="momCombatTileLayer">
	    <xsd:annotation>
    		<xsd:documentation>Stores the combat tile type ID at a particular layer of one tile of a combat map.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="layer" type="momimecommon:combatMapLayerID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="combatTileTypeID" type="momimecommon:combatTileTypeID"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="momCombatTile">
	    <xsd:annotation>
    		<xsd:documentation>Stores details about one tile of a combat map.</xsd:documentation>
		</xsd:annotation>
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="offMapEdge" type="xsd:boolean"/>
			<xsd:element minOccurs="0" maxOccurs="1" name="borderDirections" type="momimecommon:directions"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="borderID" type="momimecommon:combatTileBorderID"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="tileLayer" type="momimemsgs:momCombatTileLayer"/>
        </xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="momScheduledCombatData">
	    <xsd:annotation>
    		<xsd:documentation>Data common to stored scheduled combats and the add message.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="scheduledCombatURN" type="momimemsgs:scheduledCombatURN"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="defendingLocation" type="momimemsgs:overlandMapCoordinates"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="attackingFrom" type="momimemsgs:overlandMapCoordinates"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="defendingPlayerID" type="mps:playerID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="attackingPlayerID" type="mps:playerID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="monsterUnitID" type="momimecommon:unitID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="typeOfCombat" type="momimemsgs:moveResultsInAttackTypeID"/>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="attackingUnitURN" type="momimemsgs:unitURN"/>
		</xsd:sequence>
	</xsd:complexType>
	
	<xsd:complexType name="momScheduledCombat">
	    <xsd:annotation>
    		<xsd:documentation>Stores details about one scheduled combat that the player is involved in - players don't know about
combats that they aren't involved in, only a count of how many there are.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="momimemsgs:momScheduledCombatData">
				<xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="walkInWithoutAFight" type="xsd:boolean"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>

	<xsd:complexType name="pendingMovement">
	    <xsd:annotation>
    		<xsd:documentation>Stores details about a unit stack's future move.
    		
These will be set up in a one-at-a-time game if a unit stack cannot reach their destination in one turn (human
players only - AI players will never set a movement point outside of their current reach).

They are used in simultaneous movement games for all movement, including AI players.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="moveFrom" type="momimemsgs:overlandMapCoordinates"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="moveTo" type="momimemsgs:overlandMapCoordinates"/>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="unitURN" type="momimemsgs:unitURN"/>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="path" type="map:mapDirection"/>
		</xsd:sequence>
	</xsd:complexType>
	
	<xsd:complexType name="availableUnit">
	    <xsd:annotation>
    		<xsd:documentation>Unit data items common between available units and the server telling us to add an actual unit.</xsd:documentation>
		</xsd:annotation>
		<xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="1" name="owningPlayerID" type="mps:playerID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="unitID" type="momimecommon:unitID"/>
			<xsd:element minOccurs="1" maxOccurs="1" name="unitLocation" type="momimemsgs:overlandMapCoordinates">
			    <xsd:annotation>
    				<xsd:documentation>The current location of the unit - on the client, units being animated
to show them moving from one cell to another have their GridCell set to null.</xsd:documentation>
				</xsd:annotation>
			</xsd:element>
			<xsd:element minOccurs="0" maxOccurs="1" name="weaponGrade" type="momimecommon:weaponGradeNumber"/>
			<xsd:element minOccurs="0" maxOccurs="unbounded" name="unitHasSkill" type="momimecommon:unitHasSkill"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="memoryUnit">
	    <xsd:annotation>
    		<xsd:documentation>One unit actually bought/summoned in the game that is ours or we remember having seen.</xsd:documentation>
		</xsd:annotation>
		<xsd:complexContent>
			<xsd:extension base="momimemsgs:availableUnit">
				<xsd:sequence>
					<xsd:element minOccurs="1" maxOccurs="1" name="unitURN" type="momimemsgs:unitURN"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="heroNameID" type="momimecommon:heroNameID"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="unitName" type="momimecommon:description"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="rangedAttackAmmo" type="momimecommon:unitSkillValue"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="manaRemaining" type="momimecommon:unitSkillValue"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="damageTaken" type="momimecommon:unitAttributeValue">
					    <xsd:annotation>
    						<xsd:documentation>Number of hits damage this unit has taken (all hits are removed from the first figure
until it is dead and disappears, then from the second, and so on).</xsd:documentation>
						</xsd:annotation>
					</xsd:element>
					<xsd:element minOccurs="1" maxOccurs="1" name="doubleOverlandMovesLeft" type="momimecommon:doubleMovement"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="specialOrder" type="momimemsgs:unitSpecialOrder"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="status" type="momimemsgs:unitStatusID"/>
					<xsd:element minOccurs="1" maxOccurs="1" name="wasSummonedInCombat" type="xsd:boolean"/>

					<!-- Combat -->
					<xsd:element minOccurs="0" maxOccurs="1" name="combatLocation" type="momimemsgs:overlandMapCoordinates"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="combatPosition" type="momimemsgs:combatMapCoordinates"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="combatHeading" type="map:mapDirection"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="combatSide" type="momimemsgs:unitCombatSideID"/>
					<xsd:element minOccurs="0" maxOccurs="1" name="doubleCombatMovesLeft" type="momimecommon:doubleMovement"/>
				</xsd:sequence>
			</xsd:extension>
		</xsd:complexContent>
	</xsd:complexType>
	
<!-- Map areas -->

	<!-- Equivalent of TNDGGridMap3DStringArea -->

	<xsd:complexType name="mapRowOfStrings">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="cell" type="xsd:normalizedString"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapAreaOfStrings">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="row" type="momimemsgs:mapRowOfStrings"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapVolumeOfStrings">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="plane" type="momimemsgs:mapAreaOfStrings"/>
		</xsd:sequence>
	</xsd:complexType>

	<!-- Equivalent of TFogOfWarArea -->

	<xsd:complexType name="mapRowOfFogOfWarStates">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="cell" type="momimemsgs:fogOfWarStateID"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapAreaOfFogOfWarStates">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="row" type="momimemsgs:mapRowOfFogOfWarStates"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapVolumeOfFogOfWarStates">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="plane" type="momimemsgs:mapAreaOfFogOfWarStates"/>
		</xsd:sequence>
	</xsd:complexType>

	<!-- Equivalent of TMomMemoryMap -->

	<xsd:complexType name="mapRowOfMemoryGridCells">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="cell" type="momimemsgs:memoryGridCell"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapAreaOfMemoryGridCells">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="row" type="momimemsgs:mapRowOfMemoryGridCells"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapVolumeOfMemoryGridCells">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="plane" type="momimemsgs:mapAreaOfMemoryGridCells"/>
		</xsd:sequence>
	</xsd:complexType>
	
	<!-- Equivalent of TMomCombatMap -->

	<xsd:complexType name="mapRowOfCombatTiles">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="cell" type="momimemsgs:momCombatTile"/>
		</xsd:sequence>
	</xsd:complexType>

	<xsd:complexType name="mapAreaOfCombatTiles">
        <xsd:sequence>
			<xsd:element minOccurs="1" maxOccurs="unbounded" name="row" type="momimemsgs:mapRowOfCombatTiles"/>
		</xsd:sequence>
	</xsd:complexType>

<!-- Enums -->

	<xsd:simpleType name="turnSystem">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="O"><xsd:annotation>
				<xsd:documentation>One player at a time</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ONE_PLAYER_AT_A_TIME"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Simultaneous</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SIMULTANEOUS"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="unitSpecialOrder">
	    <xsd:annotation>
    		<xsd:documentation>Different special orders that units can be given.
All of these except for msoPatrol are only used in simultaneous turn games - in one-player-at-a-time games, these kinds of commands are executed instantly.
Units with special orders won't be asked for movement orders and look visibly different on the map.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="P"><xsd:annotation>
				<xsd:documentation>Patrol</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PATROL"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Build city</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_CITY"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Build road</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="BUILD_ROAD"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="M"><xsd:annotation>
				<xsd:documentation>Meld with node</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="MELD_WITH_NODE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>Purify</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="PURIFY"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Dismiss</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DISMISS"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="captureCityDecisionID">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Capture</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CAPTURE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Raze</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RAZE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="moveResultsInAttackTypeID">
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>No - Moving here won't result in an attack</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NO"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Y"><xsd:annotation>
				<xsd:documentation>Yes - Conventional attack - Moving here will attack enemy units walking around the map or a city (occupied or not)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="YES"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="S"><xsd:annotation>
				<xsd:documentation>Scout - Moving here will result in scouting the monsters in a node/lair/tower and giving player choice to attack them or not</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="SCOUT"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="fogOfWarStateID">
	    <xsd:annotation>
    		<xsd:documentation>Defines how well we can see a particular map cell.
Only the first 3 are real values.  The last 2 special values are used on the server when re-generating the fog of war state so it
can determine changes in the fog of war, and only send the changes to each player rather than having to resend the whole area every time.

At start of fog of war routine, possible 3 values are
fowNeverSeen, fowHaveSeen, fowCanSee

For each map cell that we find we can see, it changes:
fowNeverSeen -> fowCanNowSee
fowHaveSeen  -> fowCanNowSee
fowCanSee    -> fowCanStillSee

After sending the changes to the client, then replaces:
fowCanSee      -> fowHaveSeen, and send to client
fowCanNowSee   -> fowCanSee, and send to client
fowCanStillSee -> fowCanSee</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Never seen</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NEVER_SEEN"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="H"><xsd:annotation>
				<xsd:documentation>Have seen</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="HAVE_SEEN"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="C"><xsd:annotation>
				<xsd:documentation>Can seen</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="CAN_SEE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Y"><xsd:annotation>
				<xsd:documentation>(Special temporary value) Can now see</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="TEMP_CAN_NOW_SEE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Z"><xsd:annotation>
				<xsd:documentation>(Special temporary value) Can still see</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="TEMP_CAN_STILL_SEE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="spellResearchStatusID">
	    <xsd:annotation>
    		<xsd:documentation>Different statuses that a spell can have in a player's spell book</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="U"><xsd:annotation>
				<xsd:documentation>Unavailable - Impossible to get this spell until we get more of this type of book,
e.g. you cannot get Very Rare spells until you have 3 books, even from trading, conquering nodes or
banishing a wizard (see strategy guide p168)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="UNAVAILABLE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Not in spell book - Spell isn't in our spell book, so we can't research it - but
we might be lucky and get it through trading, conquering nodes or banishing a wizard</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NOT_IN_SPELL_BOOK"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="R"><xsd:annotation>
				<xsd:documentation>Researchable - Just not yet (e.g. you have to research most Common spells before proceeding to Uncommon, etc.)</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESEARCHABLE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="Y"><xsd:annotation>
				<xsd:documentation>Researchable now - One of the 8 options for what to research next</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="RESEARCHABLE_NOW"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Available - We've learned it</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="AVAILABLE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>

	<xsd:simpleType name="unitStatusID">
	    <xsd:annotation>
    		<xsd:documentation>Different statuses that a unit can have.
Normally, normal and summoned units are mphsAlive, however if they die in combat they temporarily go to mphsDead, so that they still exist to allow the Raise Dead spell.
Heroes are a little more complicated - they have persistent unit stats that must exist even before the hero has ever been summoned, hence the additional values.
The client doesn't learn about heroes until they've been summoned.
With Fog of War, units that walk out of visible range are removed entirely from clients' unit lists entirely (for now, v0.9.4) this includes
enemy heroes - of course we'll never lose our own heroes like this, since they'll always be able to see themselves :)</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="N"><xsd:annotation>
				<xsd:documentation>Not Generated -  Indicates that the hero's skills have not been read from the database, nor their random picks generated.
Only used when we choose for Hero picks to only be rolled as the hero is summoned, rather than at the start of the game.
Client never has any heroes at this status.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="NOT_GENERATED"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="G"><xsd:annotation>
				<xsd:documentation>Generated - Stats generated, but hero has never been hired.
Or hero has been previously hired but we dismissed them.
Available for summoning via Summon Hero or Summon Champion.
Client never has any heroes at this status.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="GENERATED"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Alive - The normal - Unit is alive and currently in use.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ALIVE"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>For units: Unit killed during the current combat, whether ours or the enemy's, so we can get a list of
potential targets for a Raise Dead spell.  Dead units are then purged at the end of the combat.

For heroes: Dead heroes are kept even after combat in case they are later resurrected.

On the client, only our own heroes ever go to DEAD - enemy heroes are removed from the unit list completely - even during combat they
are removed from the list immediately without going to DEAD, since heroes can never be the target of Raise Dead spells anyway.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DEAD"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="L"><xsd:annotation>
				<xsd:documentation>Killed by lack of production - Used on the client, so for units killed
through lack of production, we can still look up their name to show it on the new turn messages.</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="KILLED_BY_LACK_OF_PRODUCTION"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
	<xsd:simpleType name="unitCombatSideID">
	    <xsd:annotation>
    		<xsd:documentation>Keeps track of which side of combat a unit is on; null if they aren't involved in a combat at the moment'</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:normalizedString">
			<xsd:enumeration value="D"><xsd:annotation>
				<xsd:documentation>Defender</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="DEFENDER"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
			<xsd:enumeration value="A"><xsd:annotation>
				<xsd:documentation>Attacker</xsd:documentation>
				<xsd:appinfo><jaxb:typesafeEnumMember name="ATTACKER"/></xsd:appinfo>
			</xsd:annotation></xsd:enumeration>
		</xsd:restriction>
	</xsd:simpleType>
	
<!--  Simple types -->
	
	<xsd:simpleType name="unitURN">
	    <xsd:annotation>
    		<xsd:documentation>Unique identifier allocated to each unit existing in a particular game.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>

	<xsd:simpleType name="scheduledCombatURN">
	    <xsd:annotation>
    		<xsd:documentation>Unique identifier allocated to each scheduled combat queued up in one simultaneous turn.
Numbers are reset back to 1 again on each new turn.
Not used for one-player-at-a-time games since combats in those all happen instantly.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
	<xsd:simpleType name="magicPowerDistributionRatio">
	    <xsd:annotation>
    		<xsd:documentation>Value 0..240 indicating the proportion of magic power to divert into mana/research/skill improvement.</xsd:documentation>
		</xsd:annotation>
		<xsd:restriction base="xsd:double" />
	</xsd:simpleType>

	<xsd:simpleType name="turnNumber">
		<xsd:restriction base="xsd:unsignedShort" />
	</xsd:simpleType>
	
</xsd:schema>
