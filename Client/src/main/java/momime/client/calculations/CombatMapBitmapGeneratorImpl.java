package momime.client.calculations;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import momime.client.MomClient;
import momime.client.config.MomImeClientConfigEx;
import momime.client.graphics.database.AnimationGfx;
import momime.client.graphics.database.GraphicsDatabaseConstants;
import momime.client.graphics.database.GraphicsDatabaseEx;
import momime.client.graphics.database.SmoothedTileGfx;
import momime.client.graphics.database.SmoothedTileTypeGfx;
import momime.client.graphics.database.TileSetGfx;
import momime.common.database.CombatMapLayerID;
import momime.common.database.RecordNotFoundException;
import momime.common.messages.CombatMapSize;
import momime.common.messages.MapAreaOfCombatTiles;
import momime.common.utils.CombatMapUtils;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.ndg.map.CoordinateSystemUtils;
import com.ndg.map.coordinates.MapCoordinates2DEx;
import com.ndg.map.coordinates.MapCoordinates3DEx;
import com.ndg.swing.NdgUIUtils;

/**
 * Deals with deriving combat tiles and generating the combat scenery bitmap.
 */
public final class CombatMapBitmapGeneratorImpl implements CombatMapBitmapGenerator
{
	/** Class logger */
	private final Log log = LogFactory.getLog (CombatMapBitmapGeneratorImpl.class);
	
	/** Multiplayer client */
	private MomClient client;
	
	/** Graphics database */
	private GraphicsDatabaseEx graphicsDB;
	
	/** Coordinate system utils */
	private CoordinateSystemUtils coordinateSystemUtils;
	
	/** Helper methods and constants for creating and laying out Swing components */
	private NdgUIUtils utils;
	
	/** Combat map utils */
	private CombatMapUtils combatMapUtils;
	
	/** Client config, containing various combat map settings */
	private MomImeClientConfigEx clientConfig;
	
	/** Smoothed tile types to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTileTypeGfx [] []> smoothedTileTypes;

	/** Smoothed tiles to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTileGfx [] []> smoothedTiles;
	
	/**
	 * Creates the smoothedTiles array as the correct size
	 */
	@Override
	public final void afterJoinedSession ()
	{
		log.trace ("Entering afterJoinedSession");

		smoothedTiles = new HashMap<CombatMapLayerID, SmoothedTileGfx [] []> ();
		smoothedTileTypes = new HashMap<CombatMapLayerID, SmoothedTileTypeGfx [] []> ();
		
		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			smoothedTiles.put (layer, new SmoothedTileGfx [mapSize.getHeight ()] [mapSize.getWidth ()]);
			smoothedTileTypes.put (layer, new SmoothedTileTypeGfx [mapSize.getHeight ()] [mapSize.getWidth ()]);
		}

		log.trace ("Exiting afterJoinedSession");
	}	
	
	/**
	 * Converts the tile types sent by the server into actual tile numbers, smoothing the edges of various terrain types in the process
	 * 
	 * @param combatLocation Overland map coordinates where combat it taking place (we need to know e.g. what tile type it is there and what plane it is on)
	 * @param combatTerrain Scenery tiles generated by the server for this combat map
	 * @throws RecordNotFoundException If required entries in the graphics XML cannot be found
	 */
	@Override
	public final void smoothMapTerrain (final MapCoordinates3DEx combatLocation, final MapAreaOfCombatTiles combatTerrain) throws RecordNotFoundException
	{
		log.trace ("Entering smoothMapTerrain");

		// What kind of terrain are we generating images for
		final String tileTypeID = getClient ().getOurPersistentPlayerPrivateKnowledge ().getFogOfWarMemory ().getMap ().getPlane ().get
			(combatLocation.getZ ()).getRow ().get (combatLocation.getY ()).getCell ().get (combatLocation.getX ()).getTerrainData ().getTileTypeID ();
		
		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		final int maxDirection = getCoordinateSystemUtils ().getMaxDirection (mapSize.getCoordinateSystemType ());
		
		// Choose the appropriate tile set
		final TileSetGfx combatMapTileSet = getGraphicsDB ().findTileSet (GraphicsDatabaseConstants.TILE_SET_COMBAT_MAP, "smoothMapTerrain");
		
		// Now check each map cell
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			final SmoothedTileTypeGfx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
			final SmoothedTileGfx [] [] smoothedTilesLayer = smoothedTiles.get (layer);
			
			for (int y = 0; y < mapSize.getHeight (); y++) 
				for (int x = 0; x < mapSize.getWidth (); x++)
				{
					final String combatTileTypeID = getCombatMapUtils ().getCombatTileTypeForLayer (combatTerrain.getRow ().get (y).getCell ().get (x), layer);
					
					// Many tiles are blank in higher layers, like the roads/buildings layer
					if (combatTileTypeID == null)
					{
						smoothedTileTypesLayer [y] [x] = null;
						smoothedTilesLayer [y] [x] = null;
					}
					else
					{
						final SmoothedTileTypeGfx smoothedTileType = combatMapTileSet.findSmoothedTileType (tileTypeID, combatLocation.getZ (), combatTileTypeID);
						
						// If this is ticked then fix the bitmask
						// If a land based tile, want to assume grass in every direction (e.g. for mountains, draw a single mountain), so want 11111111
						
						// But for a sea tile, this looks really daft - you get a 'sea' of lakes surrounded by grass!  So we have to force these to 00000000 instead
						// to make it look remotely sensible
						
						// Rather than hard coding which tile types need 00000000 and which need 11111111, the graphics XML file has a special
						// entry under every tile for the image to use for 'NoSmooth' = No Smoothing
						final StringBuffer bitmask = new StringBuffer ();
						if (!getClientConfig ().isCombatSmoothTerrain ())
							bitmask.append (GraphicsDatabaseConstants.TILE_BITMASK_NO_SMOOTHING);
						else							
						{
							// No rivers to worry about like overland tiles, so only 2 possibilities for how we create the bitmask
							// 0 = force 00000000
							// 1 = use 0 for this type of tile, 1 for anything else (assume grass)
							final int maxValueInEachDirection = combatMapTileSet.findSmoothingSystem
								(smoothedTileType.getSmoothingSystemID (), "smoothMapTerrain").getMaxValueEachDirection ();
							
							if (maxValueInEachDirection == 0)
							{
								for (int d = 1; d <= maxDirection; d++)
									bitmask.append ("0");
							}
							
							// Normal type of smoothing
							else
							{
								for (int d = 1; d <= maxDirection; d++)
								{
									final MapCoordinates2DEx coords = new MapCoordinates2DEx (x, y);
									if (getCoordinateSystemUtils ().move2DCoordinates (mapSize, coords, d))
									{
										final String otherCombatTileTypeID = getCombatMapUtils ().getCombatTileTypeForLayer
											(combatTerrain.getRow ().get (coords.getY ()).getCell ().get (coords.getX ()), layer);
										
										if ((otherCombatTileTypeID == null) || (otherCombatTileTypeID.equals (combatTileTypeID)))
											bitmask.append ("0");
										else
											bitmask.append ("1");
									}
									else
										bitmask.append ("0");
								}
							}
						}
	
						// The cache works directly on unsmoothed bitmasks so no reduction to do
						smoothedTileTypesLayer [y] [x] = smoothedTileType;
						smoothedTilesLayer [y] [x] = smoothedTileType.getRandomImage (bitmask.toString ());
					}
				}
		}
		
		log.trace ("Exiting smoothMapTerrain");
	}

	/**
	 * Generates big bitmaps of the entire combat map in each frame of animation.
	 * Delphi client did this rather differently, by building Direct3D vertex buffers to display all the map tiles; equivalent method there was RegenerateCompleteSceneryView.
	 * 
	 * Generated bitmaps will all be the exact size of the terrain portion of the combat UI.
	 * 
	 * @param combatTerrain Scenery tiles generated by the server for this combat map (needed to look for muddy tiles)
	 * @return Array of combat map bitmaps
	 * @throws IOException If there is a problem loading any of the images
	 */
	@Override
	public final BufferedImage [] generateCombatMapBitmaps (final MapAreaOfCombatTiles combatTerrain) throws IOException
	{
		log.trace ("Entering generateCombatMapBitmaps");

		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		
		// We need the tile set so we know how many animation frames there are
		final TileSetGfx combatMapTileSet = getGraphicsDB ().findTileSet (GraphicsDatabaseConstants.TILE_SET_COMBAT_MAP, "generateCombatMapBitmap");

		// Create the set of empty bitmaps
		final BufferedImage [] combatMapBitmaps = new BufferedImage [combatMapTileSet.getAnimationFrameCount ()];
		final Graphics2D [] g = new Graphics2D [combatMapTileSet.getAnimationFrameCount ()];
		for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
		{
			combatMapBitmaps [frameNo] = new BufferedImage (640, 362, BufferedImage.TYPE_INT_ARGB);
			g [frameNo] = combatMapBitmaps [frameNo].createGraphics ();
		}
		
		// Terrain and road are static; building layer is drawn on the fly so buildings can get the correct zOrders relative to units moving in front of/behind them
		for (final CombatMapLayerID layer : new CombatMapLayerID [] {CombatMapLayerID.TERRAIN, CombatMapLayerID.ROAD})
		{
			final SmoothedTileTypeGfx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
			final SmoothedTileGfx [] [] smoothedTilesLayer = smoothedTiles.get (layer);
			
			// Run through each tile
			for (int x = 0; x < mapSize.getWidth (); x++)
				for (int y = 0; y < mapSize.getHeight (); y++)
				{
					// Terrain
					final SmoothedTileGfx tile = smoothedTilesLayer [y] [x];
					if (tile != null)
					{
						if (tile.getTileFile () != null)
						{
							// Use same image for all frames
							final BufferedImage image = getUtils ().loadImage (tile.getTileFile ());
							
							// Offset image - this is to offset things like the nature node tree and the wizard's fortress so the base sits in the middle of the tile
							int xpos = combatCoordinatesX (x, y, combatMapTileSet);
							int ypos = combatCoordinatesY (x, y, combatMapTileSet);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetX () != null)
								xpos = xpos + (smoothedTileTypesLayer [y] [x].getTileOffsetX () * 2);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetY () != null)
								ypos = ypos + (smoothedTileTypesLayer [y] [x].getTileOffsetY () * 2);
							
							// Draw images
							for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
								g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
						}
						else if (tile.getTileAnimation () != null)
						{
							// Animated tile
							// Offset image - this is to offset things like the nature node tree and the wizard's fortress so the base sits in the middle of the tile
							int xpos = combatCoordinatesX (x, y, combatMapTileSet);
							int ypos = combatCoordinatesY (x, y, combatMapTileSet);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetX () != null)
								xpos = xpos + (smoothedTileTypesLayer [y] [x].getTileOffsetX () * 2);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetY () != null)
								ypos = ypos + (smoothedTileTypesLayer [y] [x].getTileOffsetY () * 2);
							
							// Copy each animation frame over to each bitmap
							final AnimationGfx anim = getGraphicsDB ().findAnimation (tile.getTileAnimation (), "generateCombatMapBitmaps");
							for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
							{
								final BufferedImage image = getUtils ().loadImage (anim.getFrame ().get (frameNo));
								g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
							}
						}
					}
					
					// Draw mud on top of the terrain
					if ((combatTerrain != null) && (layer == CombatMapLayerID.TERRAIN) && (combatTerrain.getRow ().get (y).getCell ().get (x).isMud ()))
					{
						int xpos = combatCoordinatesX (x, y, combatMapTileSet);
						int ypos = combatCoordinatesY (x, y, combatMapTileSet);

						final AnimationGfx anim = getGraphicsDB ().findAnimation ("MUDDY_TILE", "generateCombatMapBitmaps");
						for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
						{
							final BufferedImage image = getUtils ().loadImage (anim.getFrame ().get (frameNo));
							g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
						}
					}
				}
		}

		// Clean up the drawing contexts 
		for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
			g [frameNo].dispose ();
		
		log.trace ("Exiting generateCombatMapBitmaps");
		return combatMapBitmaps;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Left edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesX (final int x, final int y, final TileSetGfx combatMapTileSet)
	{
		final int separationX = combatMapTileSet.getTileWidth () + 2;		// Because of the way the tiles slot together
		
		int result = separationX * (x-1);
		
		if (y % 2 == 1)
			result = result + (separationX/2);
		
		return result * 2;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Top edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesY (final int x, final int y, final TileSetGfx combatMapTileSet)
	{
		final int separationY = combatMapTileSet.getTileHeight () / 2;

		final int result = separationY * (y-1);
		
		return result * 2;
	}
	
	/**
	 * @return Multiplayer client
	 */
	public final MomClient getClient ()
	{
		return client;
	}
	
	/**
	 * @param obj Multiplayer client
	 */
	public final void setClient (final MomClient obj)
	{
		client = obj;
	}

	/**
	 * @return Graphics database
	 */
	public final GraphicsDatabaseEx getGraphicsDB ()
	{
		return graphicsDB;
	}

	/**
	 * @param db Graphics database
	 */
	public final void setGraphicsDB (final GraphicsDatabaseEx db)
	{
		graphicsDB = db;
	}

	/**
	 * @return Coordinate system utils
	 */
	public final CoordinateSystemUtils getCoordinateSystemUtils ()
	{
		return coordinateSystemUtils;
	}

	/**
	 * @param csu Coordinate system utils
	 */
	public final void setCoordinateSystemUtils (final CoordinateSystemUtils csu)
	{
		coordinateSystemUtils = csu;
	}

	/**
	 * @return Helper methods and constants for creating and laying out Swing components
	 */
	public final NdgUIUtils getUtils ()
	{
		return utils;
	}

	/**
	 * @param util Helper methods and constants for creating and laying out Swing components
	 */
	public final void setUtils (final NdgUIUtils util)
	{
		utils = util;
	}

	/**
	 * @return Combat map utils
	 */
	public final CombatMapUtils getCombatMapUtils ()
	{
		return combatMapUtils;
	}

	/**
	 * @param util Combat map utils
	 */
	public final void setCombatMapUtils (final CombatMapUtils util)
	{
		combatMapUtils = util;
	}

	/**
	 * @return Client config, containing various combat map settings
	 */	
	public final MomImeClientConfigEx getClientConfig ()
	{
		return clientConfig;
	}

	/**
	 * @param config Client config, containing various combat map settings
	 */
	public final void setClientConfig (final MomImeClientConfigEx config)
	{
		clientConfig = config;
	}

	/**
	 * @return Smoothed tile types to display at every map cell
	 */
	@Override
	public final Map<CombatMapLayerID, SmoothedTileTypeGfx [] []> getSmoothedTileTypes ()
	{
		return smoothedTileTypes;
	}

	/**
	 * @return Smoothed tiles to display at every map cell
	 */	
	@Override
	public final Map<CombatMapLayerID, SmoothedTileGfx [] []> getSmoothedTiles ()
	{
		return smoothedTiles;
	}
}