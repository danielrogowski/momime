package momime.client.calculations;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import com.ndg.map.coordinates.MapCoordinates3DEx;
import com.ndg.swing.NdgUIUtils;

import momime.client.MomClient;
import momime.client.graphics.database.GraphicsDatabaseConstants;
import momime.client.graphics.database.GraphicsDatabaseEx;
import momime.common.database.AnimationEx;
import momime.common.database.CombatMapLayerID;
import momime.common.database.RecordNotFoundException;
import momime.common.database.SmoothedTile;
import momime.common.database.SmoothedTileTypeEx;
import momime.common.database.TileSetEx;
import momime.common.messages.CombatMapSize;
import momime.common.messages.MapAreaOfCombatTiles;
import momime.common.utils.CombatMapUtils;

/**
 * Deals with deriving combat tiles and generating the combat scenery bitmap.
 */
public final class CombatMapBitmapGeneratorImpl implements CombatMapBitmapGenerator
{
	/** Multiplayer client */
	private MomClient client;
	
	/** Graphics database */
	private GraphicsDatabaseEx graphicsDB;
	
	/** Helper methods and constants for creating and laying out Swing components */
	private NdgUIUtils utils;
	
	/** Combat map utils */
	private CombatMapUtils combatMapUtils;
	
	/** Bitmask generator */
	private TileSetBitmaskGenerator tileSetBitmaskGenerator;
	
	/** Smoothed tile types to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTileTypeEx [] []> smoothedTileTypes;

	/** Smoothed tiles to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTile [] []> smoothedTiles;
	
	/**
	 * Creates the smoothedTiles array as the correct size
	 */
	@Override
	public final void afterJoinedSession ()
	{
		smoothedTiles = new HashMap<CombatMapLayerID, SmoothedTile [] []> ();
		smoothedTileTypes = new HashMap<CombatMapLayerID, SmoothedTileTypeEx [] []> ();
		
		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			smoothedTiles.put (layer, new SmoothedTile [mapSize.getHeight ()] [mapSize.getWidth ()]);
			smoothedTileTypes.put (layer, new SmoothedTileTypeEx [mapSize.getHeight ()] [mapSize.getWidth ()]);
		}
	}	
	
	/**
	 * Converts the tile types sent by the server into actual tile numbers, smoothing the edges of various terrain types in the process
	 * 
	 * @param combatLocation Overland map coordinates where combat it taking place (we need to know e.g. what tile type it is there and what plane it is on)
	 * @param combatTerrain Scenery tiles generated by the server for this combat map
	 * @throws RecordNotFoundException If required entries in the graphics XML cannot be found
	 */
	@Override
	public final void smoothMapTerrain (final MapCoordinates3DEx combatLocation, final MapAreaOfCombatTiles combatTerrain) throws RecordNotFoundException
	{
		// What kind of terrain are we generating images for
		final String tileTypeID = getClient ().getOurPersistentPlayerPrivateKnowledge ().getFogOfWarMemory ().getMap ().getPlane ().get
			(combatLocation.getZ ()).getRow ().get (combatLocation.getY ()).getCell ().get (combatLocation.getX ()).getTerrainData ().getTileTypeID ();
		
		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		
		// Choose the appropriate tile set
		final TileSetEx combatMapTileSet = getClient ().getClientDB ().findTileSet (GraphicsDatabaseConstants.TILE_SET_COMBAT_MAP, "smoothMapTerrain");
		
		// Now check each map cell
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			final SmoothedTileTypeEx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
			final SmoothedTile [] [] smoothedTilesLayer = smoothedTiles.get (layer);
			
			for (int y = 0; y < mapSize.getHeight (); y++) 
				for (int x = 0; x < mapSize.getWidth (); x++)
				{
					final String combatTileTypeID = getCombatMapUtils ().getCombatTileTypeForLayer (combatTerrain.getRow ().get (y).getCell ().get (x), layer);
					
					// Many tiles are blank in higher layers, like the roads/buildings layer
					if (combatTileTypeID == null)
					{
						smoothedTileTypesLayer [y] [x] = null;
						smoothedTilesLayer [y] [x] = null;
					}
					else
					{
						final SmoothedTileTypeEx smoothedTileType = combatMapTileSet.findSmoothedTileType (tileTypeID, combatLocation.getZ (), combatTileTypeID);
						final String bitmask = getTileSetBitmaskGenerator ().generateCombatMapBitmask (combatTerrain, smoothedTileType, layer, x, y);
						
						// The cache works directly on unsmoothed bitmasks so no reduction to do
						smoothedTileTypesLayer [y] [x] = smoothedTileType;
						smoothedTilesLayer [y] [x] = smoothedTileType.getRandomImage (bitmask.toString ());
					}
				}
		}
	}

	/**
	 * Generates big bitmaps of the entire combat map in each frame of animation.
	 * Delphi client did this rather differently, by building Direct3D vertex buffers to display all the map tiles; equivalent method there was RegenerateCompleteSceneryView.
	 * 
	 * Generated bitmaps will all be the exact size of the terrain portion of the combat UI.
	 * 
	 * @param combatTerrain Scenery tiles generated by the server for this combat map (needed to look for muddy tiles)
	 * @return Array of combat map bitmaps
	 * @throws IOException If there is a problem loading any of the images
	 */
	@Override
	public final BufferedImage [] generateCombatMapBitmaps (final MapAreaOfCombatTiles combatTerrain) throws IOException
	{
		final CombatMapSize mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		
		// We need the tile set so we know how many animation frames there are
		final TileSetEx combatMapTileSet = getClient ().getClientDB ().findTileSet (GraphicsDatabaseConstants.TILE_SET_COMBAT_MAP, "generateCombatMapBitmap");

		// Create the set of empty bitmaps
		final BufferedImage [] combatMapBitmaps = new BufferedImage [combatMapTileSet.getAnimationFrameCount ()];
		final Graphics2D [] g = new Graphics2D [combatMapTileSet.getAnimationFrameCount ()];
		for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
		{
			combatMapBitmaps [frameNo] = new BufferedImage (640, 362, BufferedImage.TYPE_INT_ARGB);
			g [frameNo] = combatMapBitmaps [frameNo].createGraphics ();
		}
		
		// Terrain and road are static; building layer is drawn on the fly so buildings can get the correct zOrders relative to units moving in front of/behind them
		for (final CombatMapLayerID layer : new CombatMapLayerID [] {CombatMapLayerID.TERRAIN, CombatMapLayerID.ROAD})
		{
			final SmoothedTileTypeEx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
			final SmoothedTile [] [] smoothedTilesLayer = smoothedTiles.get (layer);
			
			// Run through each tile
			for (int x = 0; x < mapSize.getWidth (); x++)
				for (int y = 0; y < mapSize.getHeight (); y++)
				{
					// Terrain
					final SmoothedTile tile = smoothedTilesLayer [y] [x];
					if (tile != null)
					{
						if (tile.getTileFile () != null)
						{
							// Use same image for all frames
							final BufferedImage image = getUtils ().loadImage (tile.getTileFile ());
							
							// Offset image - this is to offset things like the nature node tree and the wizard's fortress so the base sits in the middle of the tile
							int xpos = combatCoordinatesX (x, y, combatMapTileSet);
							int ypos = combatCoordinatesY (x, y, combatMapTileSet);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetX () != null)
								xpos = xpos + (smoothedTileTypesLayer [y] [x].getTileOffsetX () * 2);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetY () != null)
								ypos = ypos + (smoothedTileTypesLayer [y] [x].getTileOffsetY () * 2);
							
							// Draw images
							for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
								g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
						}
						else if (tile.getTileAnimation () != null)
						{
							// Animated tile
							// Offset image - this is to offset things like the nature node tree and the wizard's fortress so the base sits in the middle of the tile
							int xpos = combatCoordinatesX (x, y, combatMapTileSet);
							int ypos = combatCoordinatesY (x, y, combatMapTileSet);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetX () != null)
								xpos = xpos + (smoothedTileTypesLayer [y] [x].getTileOffsetX () * 2);
							
							if (smoothedTileTypesLayer [y] [x].getTileOffsetY () != null)
								ypos = ypos + (smoothedTileTypesLayer [y] [x].getTileOffsetY () * 2);
							
							// Copy each animation frame over to each bitmap
							final AnimationEx anim = getClient ().getClientDB ().findAnimation (tile.getTileAnimation (), "generateCombatMapBitmaps");
							for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
							{
								final BufferedImage image = getUtils ().loadImage (anim.getFrame ().get (frameNo).getImageFile ());
								g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
							}
						}
					}
					
					// Draw mud on top of the terrain
					if ((combatTerrain != null) && (layer == CombatMapLayerID.TERRAIN) && (combatTerrain.getRow ().get (y).getCell ().get (x).isMud ()))
					{
						int xpos = combatCoordinatesX (x, y, combatMapTileSet);
						int ypos = combatCoordinatesY (x, y, combatMapTileSet);

						final AnimationEx anim = getGraphicsDB ().findAnimation ("MUDDY_TILE", "generateCombatMapBitmaps");
						for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
						{
							final BufferedImage image = getUtils ().loadImage (anim.getFrame ().get (frameNo).getImageFile ());
							g [frameNo].drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
						}
					}
				}
		}

		// Clean up the drawing contexts 
		for (int frameNo = 0; frameNo < combatMapTileSet.getAnimationFrameCount (); frameNo++)
			g [frameNo].dispose ();
		
		return combatMapBitmaps;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Left edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesX (final int x, final int y, final TileSetEx combatMapTileSet)
	{
		final int separationX = combatMapTileSet.getTileWidth () + 2;		// Because of the way the tiles slot together
		
		int result = separationX * (x-1);
		
		if (y % 2 != 0)
			result = result + (separationX/2);
		
		return result * 2;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Top edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesY (@SuppressWarnings ("unused") final int x, final int y, final TileSetEx combatMapTileSet)
	{
		final int separationY = combatMapTileSet.getTileHeight () / 2;

		final int result = separationY * (y-1);
		
		return result * 2;
	}
	
	/**
	 * @return Multiplayer client
	 */
	public final MomClient getClient ()
	{
		return client;
	}
	
	/**
	 * @param obj Multiplayer client
	 */
	public final void setClient (final MomClient obj)
	{
		client = obj;
	}

	/**
	 * @return Graphics database
	 */
	public final GraphicsDatabaseEx getGraphicsDB ()
	{
		return graphicsDB;
	}

	/**
	 * @param db Graphics database
	 */
	public final void setGraphicsDB (final GraphicsDatabaseEx db)
	{
		graphicsDB = db;
	}

	/**
	 * @return Helper methods and constants for creating and laying out Swing components
	 */
	public final NdgUIUtils getUtils ()
	{
		return utils;
	}

	/**
	 * @param util Helper methods and constants for creating and laying out Swing components
	 */
	public final void setUtils (final NdgUIUtils util)
	{
		utils = util;
	}

	/**
	 * @return Combat map utils
	 */
	public final CombatMapUtils getCombatMapUtils ()
	{
		return combatMapUtils;
	}

	/**
	 * @param util Combat map utils
	 */
	public final void setCombatMapUtils (final CombatMapUtils util)
	{
		combatMapUtils = util;
	}

	/**
	 * @return Bitmask generator
	 */
	public final TileSetBitmaskGenerator getTileSetBitmaskGenerator ()
	{
		return tileSetBitmaskGenerator;
	}

	/**
	 * @param g Bitmask generator
	 */
	public final void setTileSetBitmaskGenerator (final TileSetBitmaskGenerator g)
	{
		tileSetBitmaskGenerator = g;
	}
	
	/**
	 * @return Smoothed tile types to display at every map cell
	 */
	@Override
	public final Map<CombatMapLayerID, SmoothedTileTypeEx [] []> getSmoothedTileTypes ()
	{
		return smoothedTileTypes;
	}

	/**
	 * @return Smoothed tiles to display at every map cell
	 */	
	@Override
	public final Map<CombatMapLayerID, SmoothedTile [] []> getSmoothedTiles ()
	{
		return smoothedTiles;
	}
}