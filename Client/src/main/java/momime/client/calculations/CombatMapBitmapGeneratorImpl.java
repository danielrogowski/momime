package momime.client.calculations;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import momime.client.MomClient;
import momime.client.config.v0_9_5.MomImeClientConfig;
import momime.client.graphics.database.GraphicsDatabaseConstants;
import momime.client.graphics.database.GraphicsDatabaseEx;
import momime.client.graphics.database.SmoothedTileTypeEx;
import momime.client.graphics.database.TileSetEx;
import momime.client.graphics.database.v0_9_5.SmoothedTile;
import momime.common.database.RecordNotFoundException;
import momime.common.database.v0_9_5.CombatMapLayerID;
import momime.common.messages.v0_9_5.CombatMapSizeData;
import momime.common.messages.v0_9_5.MapAreaOfCombatTiles;
import momime.common.utils.CombatMapUtils;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.ndg.map.CoordinateSystemUtils;
import com.ndg.map.coordinates.MapCoordinates2DEx;
import com.ndg.map.coordinates.MapCoordinates3DEx;
import com.ndg.swing.NdgUIUtils;

/**
 * Deals with deriving combat tiles and generating the combat scenery bitmap.
 */
public final class CombatMapBitmapGeneratorImpl implements CombatMapBitmapGenerator
{
	/** Class logger */
	private final Log log = LogFactory.getLog (CombatMapBitmapGeneratorImpl.class);
	
	/** Multiplayer client */
	private MomClient client;
	
	/** Graphics database */
	private GraphicsDatabaseEx graphicsDB;
	
	/** Coordinate system utils */
	private CoordinateSystemUtils coordinateSystemUtils;
	
	/** Helper methods and constants for creating and laying out Swing components */
	private NdgUIUtils utils;
	
	/** Combat map utils */
	private CombatMapUtils combatMapUtils;
	
	/** Client config, containing various combat map settings */
	private MomImeClientConfig clientConfig;
	
	/** Smoothed tile types to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTileTypeEx [] []> smoothedTileTypes;

	/** Smoothed tiles to display at every map cell */
	private Map<CombatMapLayerID, SmoothedTile [] []> smoothedTiles;
	
	/**
	 * Creates the smoothedTiles array as the correct size
	 */
	@Override
	public final void afterJoinedSession ()
	{
		log.trace ("Entering afterJoinedSession");

		smoothedTiles = new HashMap<CombatMapLayerID, SmoothedTile [] []> ();
		smoothedTileTypes = new HashMap<CombatMapLayerID, SmoothedTileTypeEx [] []> ();
		
		final CombatMapSizeData mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			smoothedTiles.put (layer, new SmoothedTile [mapSize.getHeight ()] [mapSize.getWidth ()]);
			smoothedTileTypes.put (layer, new SmoothedTileTypeEx [mapSize.getHeight ()] [mapSize.getWidth ()]);
		}

		log.trace ("Exiting afterJoinedSession");
	}	
	
	/**
	 * Converts the tile types sent by the server into actual tile numbers, smoothing the edges of various terrain types in the process
	 * 
	 * @param combatLocation Overland map coordinates where combat it taking place (we need to know e.g. what tile type it is there and what plane it is on)
	 * @param combatTerrain Scenery tiles generated by the server for this combat map
	 * @throws RecordNotFoundException If required entries in the graphics XML cannot be found
	 */
	@Override
	public final void smoothMapTerrain (final MapCoordinates3DEx combatLocation, final MapAreaOfCombatTiles combatTerrain) throws RecordNotFoundException
	{
		log.trace ("Entering smoothMapTerrain");

		// What kind of terrain are we generating images for
		final String tileTypeID = getClient ().getOurPersistentPlayerPrivateKnowledge ().getFogOfWarMemory ().getMap ().getPlane ().get
			(combatLocation.getZ ()).getRow ().get (combatLocation.getY ()).getCell ().get (combatLocation.getX ()).getTerrainData ().getTileTypeID ();
		
		final CombatMapSizeData mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		final int maxDirection = getCoordinateSystemUtils ().getMaxDirection (mapSize.getCoordinateSystemType ());
		
		// Choose the appropriate tile set
		final TileSetEx combatMapTileSet = getGraphicsDB ().findTileSet (GraphicsDatabaseConstants.VALUE_TILE_SET_COMBAT_MAP, "smoothMapTerrain");
		
		// Now check each map cell
		for (final CombatMapLayerID layer : CombatMapLayerID.values ())
		{
			final SmoothedTileTypeEx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
			final SmoothedTile [] [] smoothedTilesLayer = smoothedTiles.get (layer);
			
			for (int y = 0; y < mapSize.getHeight (); y++) 
				for (int x = 0; x < mapSize.getWidth (); x++)
				{
					final String combatTileTypeID = getCombatMapUtils ().getCombatTileTypeForLayer (combatTerrain.getRow ().get (y).getCell ().get (x), layer);
					
					// Many tiles are blank in higher layers, like the roads/buildings layer
					if (combatTileTypeID == null)
					{
						smoothedTileTypesLayer [y] [x] = null;
						smoothedTilesLayer [y] [x] = null;
					}
					else
					{
						final SmoothedTileTypeEx smoothedTileType = combatMapTileSet.findSmoothedTileType (tileTypeID, combatLocation.getZ (), combatTileTypeID);
						
						// If this is ticked then fix the bitmask
						// If a land based tile, want to assume grass in every direction (e.g. for mountains, draw a single mountain), so want 11111111
						
						// But for a sea tile, this looks really daft - you get a 'sea' of lakes surrounded by grass!  So we have to force these to 00000000 instead
						// to make it look remotely sensible
						
						// Rather than hard coding which tile types need 00000000 and which need 11111111, the graphics XML file has a special
						// entry under every tile for the image to use for 'NoSmooth' = No Smoothing
						final StringBuffer bitmask = new StringBuffer ();
						if (!getClientConfig ().isCombatSmoothTerrain ())
							bitmask.append (GraphicsDatabaseConstants.VALUE_TILE_BITMASK_NO_SMOOTHING);
						else							
						{
							// No rivers to worry about like overland tiles, so only 2 possibilities for how we create the bitmask
							// 0 = force 00000000
							// 1 = use 0 for this type of tile, 1 for anything else (assume grass)
							final int maxValueInEachDirection = combatMapTileSet.findSmoothingSystem
								(smoothedTileType.getSmoothingSystemID (), "smoothMapTerrain").getMaxValueEachDirection ();
							
							if (maxValueInEachDirection == 0)
							{
								for (int d = 1; d <= maxDirection; d++)
									bitmask.append ("0");
							}
							
							// Normal type of smoothing
							else
							{
								for (int d = 1; d <= maxDirection; d++)
								{
									final MapCoordinates2DEx coords = new MapCoordinates2DEx (x, y);
									if (getCoordinateSystemUtils ().move2DCoordinates (mapSize, coords, d))
									{
										final String otherCombatTileTypeID = getCombatMapUtils ().getCombatTileTypeForLayer
											(combatTerrain.getRow ().get (coords.getY ()).getCell ().get (coords.getX ()), layer);
										
										if ((otherCombatTileTypeID == null) || (otherCombatTileTypeID.equals (combatTileTypeID)))
											bitmask.append ("0");
										else
											bitmask.append ("1");
									}
									else
										bitmask.append ("0");
								}
							}
						}
	
						// The cache works directly on unsmoothed bitmasks so no reduction to do
						smoothedTileTypesLayer [y] [x] = smoothedTileType;
						smoothedTilesLayer [y] [x] = smoothedTileType.getRandomImage (bitmask.toString ());
					}
				}
		}
		
		log.trace ("Exiting smoothMapTerrain");
	}

	/**
	 * Generates big bitmaps of the entire overland map in each frame of animation.
	 * Delphi client did this rather differently, by building Direct3D vertex buffers to display all the map tiles; equivalent method there was RegenerateCompleteSceneryView.
	 * 
	 * Generated bitmaps will all be 20x countX by 18x countY pixels in size.
	 * 
	 * @return Combat map bitmap
	 * @throws IOException If there is a problem loading any of the images
	 */
	@Override
	public final BufferedImage generateCombatMapBitmap () throws IOException
	{
		log.trace ("Entering generateCombatMapBitmap");

		final CombatMapSizeData mapSize = getClient ().getSessionDescription ().getCombatMapSize ();
		
		// We need the tile set so we know how many animation frames there are
		final TileSetEx combatMapTileSet = getGraphicsDB ().findTileSet (GraphicsDatabaseConstants.VALUE_TILE_SET_COMBAT_MAP, "generateCombatMapBitmap");
		
		// Create the empty bitmap
		final BufferedImage combatMapBitmap = new BufferedImage (640, 362, BufferedImage.TYPE_INT_ARGB);
		final Graphics2D g = combatMapBitmap.createGraphics ();
		try
		{
			for (final CombatMapLayerID layer : CombatMapLayerID.values ())
			{
				final SmoothedTileTypeEx [] [] smoothedTileTypesLayer = smoothedTileTypes.get (layer);
				final SmoothedTile [] [] smoothedTilesLayer = smoothedTiles.get (layer);
				
				// Run through each tile
				for (int x = 0; x < mapSize.getWidth (); x++)
					for (int y = 0; y < mapSize.getHeight (); y++)
					{
						// Terrain
						final SmoothedTile tile = smoothedTilesLayer [y] [x];
						if (tile != null)
						{
							if (tile.getTileFile () != null)
							{
								// Use image
								final BufferedImage image = getUtils ().loadImage (tile.getTileFile ());
								
								// Offset image - this is to offset things like the nature node tree and the wizard's fortress so the base sits in the middle of the tile
								int xpos = combatCoordinatesX (x, y, combatMapTileSet);
								int ypos = combatCoordinatesY (x, y, combatMapTileSet);
								
								if (smoothedTileTypesLayer [y] [x].getTileOffsetX () != null)
									xpos = xpos + (smoothedTileTypesLayer [y] [x].getTileOffsetX () * 2);
								
								if (smoothedTileTypesLayer [y] [x].getTileOffsetY () != null)
									ypos = ypos + (smoothedTileTypesLayer [y] [x].getTileOffsetY () * 2);
								
								// Draw image
								g.drawImage (image, xpos, ypos, image.getWidth () * 2, image.getHeight () * 2, null);
							}
							else if (tile.getTileAnimation () != null)
								throw new UnsupportedOperationException ("generateCombatMapBitmap: Doesn't support animated combat tiles (" + tile.getTileAnimation () + ")");
						}
					}
			}
		}
		finally
		{
			g.dispose ();
		}
		
		log.trace ("Exiting generateCombatMapBitmap");
		return combatMapBitmap;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Left edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesX (final int x, final int y, final TileSetEx combatMapTileSet)
	{
		final int separationX = combatMapTileSet.getTileWidth () + 2;		// Because of the way the tiles slot together
		
		int result = separationX * (x-1);
		
		if (y % 2 == 1)
			result = result + (separationX/2);
		
		return result * 2;
	}
	
	/**
	 * @param x Coordinates of a particular combat tile
	 * @param y Coordinates of a particular combat tile
	 * @param combatMapTileSet Combat map tile set
	 * @return Top edge of tile in pixel coordinates
	 */
	@Override
	public final int combatCoordinatesY (final int x, final int y, final TileSetEx combatMapTileSet)
	{
		final int separationY = combatMapTileSet.getTileHeight () / 2;

		final int result = separationY * (y-1);
		
		return result * 2;
	}
	
	/**
	 * @return Multiplayer client
	 */
	public final MomClient getClient ()
	{
		return client;
	}
	
	/**
	 * @param obj Multiplayer client
	 */
	public final void setClient (final MomClient obj)
	{
		client = obj;
	}

	/**
	 * @return Graphics database
	 */
	public final GraphicsDatabaseEx getGraphicsDB ()
	{
		return graphicsDB;
	}

	/**
	 * @param db Graphics database
	 */
	public final void setGraphicsDB (final GraphicsDatabaseEx db)
	{
		graphicsDB = db;
	}

	/**
	 * @return Coordinate system utils
	 */
	public final CoordinateSystemUtils getCoordinateSystemUtils ()
	{
		return coordinateSystemUtils;
	}

	/**
	 * @param csu Coordinate system utils
	 */
	public final void setCoordinateSystemUtils (final CoordinateSystemUtils csu)
	{
		coordinateSystemUtils = csu;
	}

	/**
	 * @return Helper methods and constants for creating and laying out Swing components
	 */
	public final NdgUIUtils getUtils ()
	{
		return utils;
	}

	/**
	 * @param util Helper methods and constants for creating and laying out Swing components
	 */
	public final void setUtils (final NdgUIUtils util)
	{
		utils = util;
	}

	/**
	 * @return Combat map utils
	 */
	public final CombatMapUtils getCombatMapUtils ()
	{
		return combatMapUtils;
	}

	/**
	 * @param util Combat map utils
	 */
	public final void setCombatMapUtils (final CombatMapUtils util)
	{
		combatMapUtils = util;
	}

	/**
	 * @return Client config, containing various combat map settings
	 */	
	public final MomImeClientConfig getClientConfig ()
	{
		return clientConfig;
	}

	/**
	 * @param config Client config, containing various combat map settings
	 */
	public final void setClientConfig (final MomImeClientConfig config)
	{
		clientConfig = config;
	}
}